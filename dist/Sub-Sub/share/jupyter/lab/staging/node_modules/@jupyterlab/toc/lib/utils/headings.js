// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
import { CodeCell } from '@jupyterlab/cells';
/**
 * Tests whether a heading is a notebook heading.
 *
 * @param heading - heading to test
 * @returns boolean indicating whether a heading is a notebook heading
 */
const isNotebookHeading = (heading) => {
    return heading.type !== undefined && heading.cellRef !== undefined;
};
/**
 * Runs runnable code cells.
 *
 * @private
 * @param headings - list of headings
 * @param heading - heading
 */
const runNestedCodeCells = (headings, heading) => {
    var _a;
    let h;
    let i;
    if (!isNotebookHeading(heading)) {
        return;
    }
    let runCode = [];
    // Find the heading in the list of headings...
    i = headings.indexOf(heading);
    // Check if the current heading is a "code" heading...
    h = heading;
    if (h.type === 'code') {
        runCode.push(h);
    }
    else {
        // Check for nested code headings...
        const level = heading.level;
        for (i = i + 1; i < headings.length; i++) {
            h = headings[i];
            if (h.level <= level) {
                break;
            }
            if (h.type === 'code') {
                runCode.push(h);
            }
        }
    }
    // Run each of the associated code cells...
    for (i = 0; i < runCode.length; i++) {
        if (runCode[i].cellRef) {
            const cell = runCode[i].cellRef;
            const panel = (_a = cell.parent) === null || _a === void 0 ? void 0 : _a.parent;
            if (panel) {
                void CodeCell.execute(cell, panel.sessionContext);
            }
        }
    }
};
export { runNestedCodeCells };
export { isNotebookHeading };
//# sourceMappingURL=headings.js.map