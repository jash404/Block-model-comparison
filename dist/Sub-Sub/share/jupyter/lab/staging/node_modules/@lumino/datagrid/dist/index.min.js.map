{"version":3,"sources":["../src/basickeyhandler.ts","../src/basicmousehandler.ts","../../../node_modules/tslib/tslib.es6.js","../src/selectionmodel.ts","../src/basicselectionmodel.ts","../src/cellrenderer.ts","../src/notification.ts","../src/celleditor.ts","../src/datamodel.ts","../src/graphicscontext.ts","../src/textrenderer.ts","../src/sectionlist.ts","../src/renderermap.ts","../src/celleditorcontroller.ts","../src/datagrid.ts","../src/jsonmodel.ts"],"names":["BasicKeyHandler","this","_disposed","Object","defineProperty","prototype","dispose","onKeyDown","grid","event","editable","selectionModel","cursorRow","cursorColumn","input","String","fromCharCode","keyCode","test","cell","row","column","editorController","edit","getKeyboardLayout","keyForKeydownEvent","stopPropagation","preventDefault","onArrowLeft","onArrowRight","onArrowUp","onArrowDown","onPageUp","onPageDown","onEscape","onDelete","onKeyC","moveCursor","shiftKey","scrollToCursor","model","shift","accel","Platform","accelKey","mode","selectionMode","scrollTo","scrollY","r1","r2","c1","c2","cr","cc","clear","r","c","cs","currentSelection","select","scrollToColumn","scrollByStep","maxScrollX","Infinity","scrollX","scrollToRow","maxScrollY","n","Math","floor","pageHeight","defaultSizes","rowHeight","scrollByPage","isEmpty","dataModel","maxRow","rowCount","maxColumn","columnCount","it","selections","s","undefined","next","sr1","max","min","sc1","sr2","sc2","setData","copyToClipboard","BasicMouseHandler","_pressData","release","type","timeout","override","onMouseHover","hit","hitTest","clientX","clientY","handle","Private","resizeHandleForHitTest","cursor","cursorForHandle","viewport","node","style","onMouseLeave","onMouseDown","region","model_1","r1_1","c1_1","r2_1","c2_1","cursorRow_1","cursorColumn_1","clear_1","override_1","Drag","overrideCursor","localX","localY","rgn","index","size","rowSize","override_3","columnSize","override_2","onMouseMove","data","_a","mapToLocal","lx","ly","hw","headerWidth","hh","headerHeight","vpw","viewportWidth","vph","viewportHeight","sx","sy","msx","msy","computeTimeout","setTimeout","autoselect","_b","mapToVirtual","vx","vy","bodyWidth","bodyHeight","rowAt","columnAt","dx","resizeColumn","dy","resizeRow","onMouseUp","onMouseDoubleClick","onContextMenu","onWheel","deltaX","deltaY","deltaMode","ds","columnWidth","pageWidth","scrollBy","cursorMap","result","lw","x","lh","y","tw","width","th","height","scrollToCell","delta","abs","top","left","right","bottom","none","extendStatics","d","b","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","create","__assign","assign","t","i","arguments","length","call","apply","SelectionModel","options","_changed","Signal","_selectionMode","changed","connect","onDataModelChanged","value","isRowSelected","some","containsRow","isColumnSelected","containsColumn","isCellSelected","containsCell","sender","args","emitChanged","emit","selection","BasicSelectionModel","_this","_super","_cursorRow","_cursorColumn","_cursorRectIndex","_selections","moveCursorWithinSelections","direction","firstSelection","cursorRect","dr","dc","newRow","newColumn","moveToNextRect","moveToPreviousRect","iter","pop","push","lr","lc","j","CellRenderer","resolveOption","option","config","Notification","createNode","_message","addClass","setFlag","Widget","Flag","DisallowLayout","_target","target","message","_placement","placement","attach","document","body","close","handleEvent","_evtMouseDown","update","getElementsByClassName","onBeforeAttach","msg","addEventListener","onAfterDetach","removeEventListener","onUpdateRequest","targetRect","getBoundingClientRect","alignItems","justifyContent","messageNode","innerHTML","button","createElement","container","className","appendChild","PassInputValidator","validate","valid","TextInputValidator","minLength","Number","NaN","maxLength","pattern","isNaN","IntegerInputValidator","NumberInputValidator","CellEditor","inputChanged","validityNotification","_validInput","_gridWheelEventHandler","_closeValidityNotification","removeChild","viewportOccluder","onCommit","onCancel","validator","createValidatorBasedOnType","updatePosition","_addContainer","startEditing","cancel","getInput","error","console","log","setValidity","editorContainer","classList","remove","add","show","metadata","format","RegExp","constraint","minimum","maximum","getCellInfo","columnX","columnOffset","rowY","rowOffset","cellInfo","position","visibility","commit","cursorMovement","pointerEvents","InputCellEditor","_onKeyDown","_onBlur","_onInput","isDisposed","_unbindEvents","createWidget","deserialize","focus","bindEvents","toString","spellcheck","inputType","TextCellEditor","NumberCellEditor","step","trim","floatValue","parseFloat","Error","IntegerCellEditor","intValue","parseInt","DateCellEditor","_createWidget","_input","_deserialize","_bindEvents","BooleanCellEditor","checked","OptionCellEditor","_isMultiSelect","_select","multiple","values","item","selected","indexOf","selectedOptions","editorContainerRect","maxHeight","isArray","_i","value_1","items","enum","items_1","text","bind","DynamicOptionCellEditor","list","id","valueSet","Set","forEach","setAttribute","DataModel","emptyMetadata","MutableDataModel","freeze","TextRenderer","GraphicsContext","context","_context","_state","State","restore","fillStyle","strokeStyle","font","textAlign","textBaseline","lineCap","lineDashOffset","lineJoin","lineWidth","miterLimit","shadowBlur","shadowColor","shadowOffsetX","shadowOffsetY","imageSmoothingEnabled","globalAlpha","globalCompositeOperation","getLineDash","setLineDash","segments","rotate","angle","scale","transform","m11","m12","m21","m22","translate","setTransform","save","beginPath","closePath","isPointInPath","fillRule","arc","radius","startAngle","endAngle","anticlockwise","arcTo","x1","y1","x2","y2","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","ellipse","radiusX","radiusY","rotation","lineTo","moveTo","quadraticCurveTo","cpx","cpy","rect","w","h","clip","fill","stroke","clearRect","fillRect","fillText","maxWidth","strokeRect","strokeText","measureText","createLinearGradient","x0","y0","createRadialGradient","r0","createPattern","image","repetition","createImageData","getImageData","sw","sh","putImageData","drawImage","drawFocusIfNeeded","element","pi","pool","state","other","textColor","backgroundColor","verticalAlignment","horizontalAlignment","formatGeneric","elideDirection","wrapText","paint","gc","drawBackground","drawText","color","vAlign","hAlign","boxHeight","textX","textY","boxWidth","textHeight","measureFontHeight","textWidth","wordsInColumn","split","curY","textInCurrentLine","curLineTextWidth","curSubString","substring","nextLineText","curWord","incrementedText","join","missing","formatFixed","digits","toFixed","formatPrecision","toPrecision","formatExponential","toExponential","formatIntlNumber","nft","Intl","NumberFormat","locales","formatDate","Date","toDateString","formatTime","toTimeString","formatISODateTime","toISOString","formatUTCDateTime","toUTCString","formatIntlDateTime","dtf","DateTimeFormat","fontHeightCache","fontMeasurementGC","normFont","fontMeasurementNode","offsetHeight","canvas","textContent","getContext","RendererMap","fallback","_values","_fallback","get","renderer","err","SectionList","_count","_length","_sections","_minimumSize","minimumSize","_defaultSize","defaultSize","prev","curr","count","offset","clampSize","ArrayExt","lowerBound","offsetCmp","section","span","offsetOf","indexCmp","extentOf","sizeOf","resize","insert","removed","splice","k","move","destination","i1","k1","i2","k2","upperBound","pivot","count1","count2","span1","span2","k3","reset","CellEditorController","_editor","_cell","_typeBasedOverrides","Map","_metadataBasedOverrides","setEditor","identifier","editor","set","key","_metadataIdentifierToKey","_onCommit","_onCancel","_getEditor","response","_getDataTypeKey","_objectToKey","object","str","_metadataMatchesIdentifier","identifierValue","metadataValue","_getMetadataBasedEditor","editorMatched","dtKey","has","DataGrid","_scrollX","_scrollY","_viewportWidth","_viewportHeight","_mousedown","_keyHandler","_mouseHandler","_vScrollBarMinWidth","_hScrollBarMinHeight","_dpiRatio","ceil","window","devicePixelRatio","_dataModel","_selectionModel","_editingEnabled","_style","defaultStyle","_stretchLastRow","stretchLastRow","_stretchLastColumn","stretchLastColumn","_headerVisibility","headerVisibility","_cellRenderers","cellRenderers","_copyConfig","copyConfig","defaultCopyConfig","_onRenderersChanged","minimumSizes","_rowSections","_columnSections","_rowHeaderSections","rowHeaderWidth","_columnHeaderSections","columnHeaderHeight","_canvas","createCanvas","_buffer","_overlay","_canvasGC","_bufferGC","_overlayGC","_viewport","tabIndex","outline","_vScrollBar","ScrollBar","orientation","_hScrollBar","_scrollCorner","_editorController","MessageLoop","installMessageHook","hide","thumbMoved","_onThumbMoved","pageRequested","_onPageRequested","stepRequested","_onStepRequested","GridLayout","setCellConfig","layout","rowSpacing","columnSpacing","fitPolicy","setRowStretch","setColumnStretch","addWidget","_releaseMouse","disconnect","_onDataModelChanged","_syncViewport","_onSelectionsChanged","repaintOverlay","repaintContent","controller","enabled","nr","vy1","vy2","nc","vx1","vx2","currentSel","dir","rows","columns","postMessage","ScrollRequest","bh","ph","bw","pw","RowResizeRequest","ColumnResizeRequest","resetRows","resetColumns","row_1","column_1","row_2","column_2","row_3","column_3","row_4","column_4","toArray","alert","br","bc","_c","rhc","chr","separator","headers","warningThreshold","colCount","cellCount","confirm","cells","map","ClipboardExt","copyText","processMessage","vsbLimits","ElementExt","sizeLimits","hsbLimits","minWidth","minHeight","messageHook","handler","_processViewportMessage","activate","_evtKeyDown","_evtMouseMove","_evtMouseUp","_evtMouseDoubleClick","_evtMouseLeave","_evtContextMenu","_evtWheel","_refreshDPI","onActivateRequest","onBeforeShow","onResize","_syncScrollState","PaintRequest","repaintRegion","OverlayPaintRequest","_resizeCanvasIfNeeded","maxW","maxH","curW","curH","expW","expH","needBlit","hasVScroll","isHidden","hasHScroll","vsw","hsh","apw","aph","needVScroll","needHScroll","setHidden","sendMessage","Msg","FitRequest","page","_scrollTo","_onViewportResize","_onViewportScrollRequest","_onViewportPaintRequest","_onViewportOverlayPaintRequest","_onViewportRowResizeRequest","_onViewportColumnResizeRequest","isVisible","offsetWidth","round","oldWidth","oldHeight","paintContent","_paintOverlay","bx","by","xMax","yMax","rs","rhs","chs","_resizeRow","_resizeColumnHeader","_resizeColumn","_resizeRowHeader","_onRowsInserted","_onColumnsInserted","_onRowsRemoved","_onColumnsRemoved","_onRowsMoved","_onColumnsMoved","_onCellsChanged","_onModelReset","rowSpan","columnSpan","nrh","nch","drh","dch","dpiRatio","oldSize","newSize","vw","vh","pos","_blitContent","contentX","contentY","contentWidth","contentHeight","dxArea","dyArea","y_5","x_6","source","rx","ry","rw","rh","_drawVoidRegion","_drawBodyRegion","_drawRowHeaderRegion","_drawColumnHeaderRegion","drawCornerHeaderRegion","_drawBodySelections","_drawRowHeaderSelections","_drawColumnHeaderSelections","_drawCursor","_drawShadows","voidColor","contentW","contentH","rowSizes","columnSizes","dh","dw","xMin","yMin","_drawBackground","_drawRowBackground","rowBackgroundColor","_drawColumnBackground","columnBackgroundColor","_drawCells","_drawHorizontalGridLines","horizontalGridLineColor","gridLineColor","_drawVerticalGridLines","verticalGridLineColor","headerBackgroundColor","headerHorizontalGridLineColor","headerGridLineColor","headerVerticalGridLineColor","colorFn","n_1","selectionFillColor","selectionBorderColor","tmp","headerSelectionFillColor","headerSelectionBorderColor","maxCol","cursorFillColor","cursorBorderColor","shadow","scrollShadow","sxMax","syMax","grad","addColorStop","color1","color2","color3","copyFormatGeneric","ConflatableMessage","_region","_r1","_c1","_r2","_c2","conflate","_index","_size","JSONModel","splitFields","schema","_data","_bodyFields","bodyFields","_headerFields","headerFields","_missingValues","createMissingMap","field","name","title","primaryKeys","primaryKey","fields","missingValues"],"mappings":"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","sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  Platform\n} from '@lumino/domutils';\n\nimport {\n  getKeyboardLayout\n} from '@lumino/keyboard';\n\nimport {\n  DataGrid\n} from './datagrid';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  CellEditor\n} from './celleditor';\n\nimport {\n  MutableDataModel\n} from './datamodel';\n\n\n/**\n * A basic implementation of a data grid key handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport\nclass BasicKeyHandler implements DataGrid.IKeyHandler {\n  /**\n   * Whether the key handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by the key handler.\n   */\n  dispose(): void {\n    this._disposed = true;\n  }\n\n  /**\n   * Handle the key down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keydown event of interest.\n   *\n   * #### Notes\n   * This will not be called if the mouse button is pressed.\n   */\n  onKeyDown(grid: DataGrid, event: KeyboardEvent): void {\n    // if grid is editable and cell selection available, start cell editing\n    // on key press (letters, numbers and space only)\n    if (grid.editable && \n      grid.selectionModel!.cursorRow !== -1 &&\n      grid.selectionModel!.cursorColumn !== -1) {\n      const input = String.fromCharCode(event.keyCode);\n      if (/[a-zA-Z0-9-_ ]/.test(input)) {\n        const row = grid.selectionModel!.cursorRow;\n        const column = grid.selectionModel!.cursorColumn;\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n        if (getKeyboardLayout().keyForKeydownEvent(event) === 'Space') {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n        return;\n      }\n    }\n\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n    case 'ArrowLeft':\n      this.onArrowLeft(grid, event);\n      break;\n    case 'ArrowRight':\n      this.onArrowRight(grid, event);\n      break;\n    case 'ArrowUp':\n      this.onArrowUp(grid, event);\n      break;\n    case 'ArrowDown':\n      this.onArrowDown(grid, event);\n      break;\n    case 'PageUp':\n      this.onPageUp(grid, event);\n      break;\n    case 'PageDown':\n      this.onPageDown(grid, event);\n      break;\n    case 'Escape':\n      this.onEscape(grid, event);\n      break;\n    case 'Delete':\n      this.onDelete(grid, event);\n      break;\n    case 'C':\n      this.onKeyC(grid, event);\n      break;\n    case 'Enter':\n      if (grid.selectionModel) {\n        grid.moveCursor(event.shiftKey ? 'up' : 'down');\n        grid.scrollToCursor();\n      }\n      break;\n    case 'Tab':\n      if (grid.selectionModel) {\n        grid.moveCursor(event.shiftKey ? 'left' : 'right');\n        grid.scrollToCursor();\n        event.stopPropagation();\n        event.preventDefault();\n      }\n      break;\n    }\n  }\n\n  /**\n   * Handle the `'ArrowLeft'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowLeft(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection mode with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(0, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('left');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 - 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = 0;\n      c2 = 0;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c - 1;\n      c2 = c - 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowRight'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowRight(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the row selection model with accel key.\n    if (mode === 'row' && accel) {\n      grid.scrollTo(grid.maxScrollX, grid.scrollY);\n      return;\n    }\n\n    // Handle the row selection mode with no modifier. (ignore shift)\n    if (mode === 'row') {\n      grid.scrollByStep('right');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = Infinity;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 + 1 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = r;\n      r2 = r;\n      c1 = Infinity;\n      c2 = Infinity;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r;\n      r2 = r;\n      c1 = c + 1;\n      c2 = c + 1;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, 0);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('up');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = 0;\n      r2 = 0;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r - 1;\n      r2 = r - 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'ArrowDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onArrowDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // Handle no model with the accel modifier.\n    if (!model && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle no model and no modifier. (ignore shift)\n    if (!model) {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Handle the column selection mode with accel key.\n    if (mode === 'column' && accel) {\n      grid.scrollTo(grid.scrollX, grid.maxScrollY);\n      return;\n    }\n\n    // Handle the column selection mode with no modifier. (ignore shift)\n    if (mode === 'column') {\n      grid.scrollByStep('down');\n      return;\n    }\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Dispatch based on the modifier keys.\n    if (accel && shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = Infinity;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (shift) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + 1 : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else if (accel) {\n      r1 = Infinity;\n      r2 = Infinity;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    } else {\n      r1 = r + 1;\n      r2 = r + 1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c1;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    if (shift || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else {\n      grid.scrollToCursor();\n    }\n  }\n\n  /**\n   * Handle the `'PageUp'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageUp(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('up');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n =  Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 - n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 - n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'PageDown'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onPageDown(grid: DataGrid, event: KeyboardEvent): void {\n    // Ignore the event if the accel key is pressed.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Scroll by page if there is no selection model.\n    if (!model || model.selectionMode === 'column') {\n      grid.scrollByPage('down');\n      return;\n    }\n\n    // Get the normal number of cells in the page height.\n    let n =  Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);\n\n    // Fetch the cursor and selection.\n    let r = model.cursorRow;\n    let c = model.cursorColumn;\n    let cs = model.currentSelection();\n\n    // Set up the selection variables.\n    let r1: number;\n    let r2: number;\n    let c1: number;\n    let c2: number;\n    let cr: number;\n    let cc: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Select or resize as needed.\n    if (event.shiftKey) {\n      r1 = cs ? cs.r1 : 0;\n      r2 = cs ? cs.r2 + n : 0;\n      c1 = cs ? cs.c1 : 0;\n      c2 = cs ? cs.c2 : 0;\n      cr = r;\n      cc = c;\n      clear = 'current';\n    } else {\n      r1 = cs ? cs.r1 + n : 0;\n      r2 = r1;\n      c1 = c;\n      c2 = c;\n      cr = r1;\n      cc = c;\n      clear = 'all';\n    }\n\n    // Create the new selection.\n    model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return;\n    }\n\n    // Scroll the grid appropriately.\n    grid.scrollToRow(cs.r2);\n  }\n\n  /**\n   * Handle the `'Escape'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onEscape(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.selectionModel) {\n      grid.selectionModel.clear();\n    }\n  }\n\n  /**\n   * Handle the `'Delete'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onDelete(grid: DataGrid, event: KeyboardEvent): void {\n    if (grid.editable &&\n      !grid.selectionModel!.isEmpty) {\n      const dataModel = grid.dataModel as MutableDataModel;\n      // Fetch the max row and column.\n      let maxRow = dataModel.rowCount('body') - 1;\n      let maxColumn = dataModel.columnCount('body') - 1;\n\n      const it = grid.selectionModel!.selections();\n      let s: SelectionModel.Selection | undefined;\n      while ((s = it.next()) !== undefined) {\n        // Clamp the cell to the model bounds.\n        let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n        let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n        let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n        let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n        for (let r = sr1; r <= sr2; ++r) {\n          for (let c = sc1; c <= sc2; ++c) {\n            dataModel.setData('body', r, c, null);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle the `'C'` key press for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The keyboard event of interest.\n   */\n  protected onKeyC(grid: DataGrid, event: KeyboardEvent): void {\n    // Bail early if the modifiers aren't correct for copy.\n    if (event.shiftKey || !Platform.accelKey(event)) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Copy the current selection to the clipboard.\n    grid.copyToClipboard();\n  }\n\n  private _disposed = false;\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\nimport {\n  Platform\n} from '@lumino/domutils';\n\nimport {\n  Drag\n} from '@lumino/dragdrop';\n\nimport {\n  DataGrid\n} from './datagrid';\n\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  CellEditor\n} from './celleditor';\n\n/**\n * A basic implementation of a data grid mouse handler.\n *\n * #### Notes\n * This class may be subclassed and customized as needed.\n */\nexport\nclass BasicMouseHandler implements DataGrid.IMouseHandler {\n  /**\n   * Dispose of the resources held by the mouse handler.\n   */\n  dispose(): void {\n    // Bail early if the handler is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Release any held resources.\n    this.release();\n\n    // Mark the handler as disposed.\n    this._disposed = true;\n  }\n\n  /**\n   * Whether the mouse handler is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Release the resources held by the handler.\n   */\n  release(): void {\n    // Bail early if the is no press data.\n    if (!this._pressData) {\n      return;\n    }\n\n    // Clear the autoselect timeout.\n    if (this._pressData.type === 'select') {\n      this._pressData.timeout = -1;\n    }\n\n    // Clear the press data.\n    this._pressData.override.dispose();\n    this._pressData = null;\n  }\n\n  /**\n   * Handle the mouse hover event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseHover(grid: DataGrid, event: MouseEvent): void {\n    // Hit test the grid.\n    let hit = grid.hitTest(event.clientX, event.clientY);\n\n    // Get the resize handle for the hit test.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Update the viewport cursor based on the part.\n    grid.viewport.node.style.cursor = cursor;\n\n    // TODO support user-defined hover items\n  }\n\n  /**\n   * Handle the mouse leave event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse hover event of interest.\n   */\n  onMouseLeave(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined hover popups.\n\n    // Clear the viewport cursor.\n    grid.viewport.node.style.cursor = '';\n  }\n\n  /**\n   * Handle the mouse down event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse down event of interest.\n   */\n  onMouseDown(grid: DataGrid, event: MouseEvent): void {\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    let { region, row, column } = hit;\n\n    // Bail if the hit test is on an uninteresting region.\n    if (region === 'void') {\n      return;\n    }\n\n    // Fetch the modifier flags.\n    let shift = event.shiftKey;\n    let accel = Platform.accelKey(event);\n\n    // If the hit test is the body region, the only option is select.\n    if (region === 'body') {\n      // Fetch the selection model.\n      let model = grid.selectionModel;\n\n      // Bail early if there is no selection model.\n      if (!model) {\n        return;\n      }\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor('default');\n\n      // Set up the press data.\n      this._pressData = {\n        type: 'select', region, row, column, override,\n        localX: -1, localY: -1, timeout: -1\n      };\n\n      // Set up the selection variables.\n      let r1: number;\n      let c1: number;\n      let r2: number;\n      let c2: number;\n      let cursorRow: number;\n      let cursorColumn: number;\n      let clear: SelectionModel.ClearMode;\n\n      // Accel == new selection, keep old selections.\n      if (accel) {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'none';\n      } else if (shift) {\n        r1 = model.cursorRow;\n        r2 = row;\n        c1 = model.cursorColumn;\n        c2 = column;\n        cursorRow = model.cursorRow;\n        cursorColumn = model.cursorColumn;\n        clear = 'current';\n      } else {\n        r1 = row;\n        r2 = row;\n        c1 = column;\n        c2 = column;\n        cursorRow = row;\n        cursorColumn = column;\n        clear = 'all';\n      }\n\n      // Use selection mode 'cell'\n      model.selectionMode = 'cell';\n\n      // Make the selection.\n      model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the hit test is on a header region.\n\n    // Convert the hit test into a part.\n    let handle = Private.resizeHandleForHitTest(hit);\n\n    // Fetch the cursor for the handle.\n    let cursor = this.cursorForHandle(handle);\n\n    // Handle horizontal resize.\n    if (handle === 'left' || handle === 'right' ) {\n      // Set up the resize data type.\n      let type: 'column-resize' = 'column-resize';\n\n      // Determine the column region.\n      let rgn: DataModel.ColumnRegion = (\n        region === 'column-header' ? 'body' : 'row-header'\n      );\n\n      // Determine the section index.\n      let index = handle === 'left' ? column - 1 : column;\n\n      // Fetch the section size.\n      let size = grid.columnSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientX, override };\n\n      // Done.\n      return;\n    }\n\n    // Handle vertical resize\n    if (handle === 'top' || handle === 'bottom') {\n      // Set up the resize data type.\n      let type: 'row-resize' = 'row-resize';\n\n      // Determine the row region.\n      let rgn: DataModel.RowRegion = (\n        region === 'row-header' ? 'body' : 'column-header'\n      );\n\n      // Determine the section index.\n      let index = handle === 'top' ? row - 1 : row;\n\n      // Fetch the section size.\n      let size = grid.rowSize(rgn, index);\n\n      // Override the document cursor.\n      let override = Drag.overrideCursor(cursor);\n\n      // Create the temporary press data.\n      this._pressData = { type, region: rgn, index, size, clientY, override };\n\n      // Done.\n      return;\n    }\n\n    // Otherwise, the only option is select.\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail if there is no selection model.\n    if (!model) {\n      return;\n    }\n\n    // Override the document cursor.\n    let override = Drag.overrideCursor('default');\n\n    // Set up the press data.\n    this._pressData = {\n      type: 'select', region, row, column, override,\n      localX: -1, localY: -1, timeout: -1\n    };\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow: number;\n    let cursorColumn: number;\n    let clear: SelectionModel.ClearMode;\n\n    // Compute the selection based on the pressed region.\n    if (region === 'corner-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'row-header') {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n      c1 = 0;\n      c2 = Infinity;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else if (region === 'column-header') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n      cursorRow = accel ? 0 : shift ? model.cursorRow : 0;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    } else {\n      r1 = accel ? row : shift ? model.cursorRow : row;\n      r2 = row;\n      c1 = accel ? column : shift ? model.cursorColumn : column;\n      c2 = column;\n      cursorRow = accel ? row : shift ? model.cursorRow : row;\n      cursorColumn = accel ? column : shift ? model.cursorColumn : column;\n      clear = accel ? 'none' : shift ? 'current' : 'all';\n    }\n\n    // Set selection mode based on region\n    switch (region) {\n      case 'column-header':\n        model.selectionMode = 'column';\n        break;\n      case 'row-header':\n        model.selectionMode = 'row';\n        break;\n      default:\n        model.selectionMode = 'cell';\n        break;\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse move event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse move event of interest.\n   */\n  onMouseMove(grid: DataGrid, event: MouseEvent): void {\n    // Fetch the press data.\n    const data = this._pressData;\n\n    // Bail early if there is no press data.\n    if (!data) {\n      return;\n    }\n\n    // Handle a row resize.\n    if (data.type === 'row-resize') {\n      let dy = event.clientY - data.clientY;\n      grid.resizeRow(data.region, data.index, data.size + dy);\n      return;\n    }\n\n    // Handle a column resize.\n    if (data.type === 'column-resize') {\n      let dx = event.clientX - data.clientX;\n      grid.resizeColumn(data.region, data.index, data.size + dx);\n      return;\n    }\n\n    // Otherwise, it's a select.\n\n    // Mouse moves during a corner header press are a no-op.\n    if (data.region === 'corner-header') {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model was removed.\n    if (!model) {\n      return;\n    }\n\n    // Map to local coordinates.\n    let { lx, ly } = grid.mapToLocal(event.clientX, event.clientY);\n\n    // Update the local mouse coordinates in the press data.\n    data.localX = lx;\n    data.localY = ly;\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n    let sx = grid.scrollX;\n    let sy = grid.scrollY;\n    let msx = grid.maxScrollY;\n    let msy = grid.maxScrollY;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Set up the timeout variable.\n    let timeout = -1;\n\n    // Compute the timemout based on hit region and mouse position.\n    if (data.region === 'row-header' || mode === 'row') {\n      if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    } else if (data.region === 'column-header' || mode === 'column') {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      }\n    } else {\n      if (lx < hw && sx > 0) {\n        timeout = Private.computeTimeout(hw - lx);\n      } else if (lx >= vpw && sx < msx) {\n        timeout = Private.computeTimeout(lx - vpw);\n      } else if (ly < hh && sy > 0) {\n        timeout = Private.computeTimeout(hh - ly);\n      } else if (ly >= vph && sy < msy) {\n        timeout = Private.computeTimeout(ly - vph);\n      }\n    }\n\n    // Update or initiate the autoselect if needed.\n    if (timeout >= 0) {\n      if (data.timeout < 0) {\n        data.timeout = timeout;\n        setTimeout(() => { Private.autoselect(grid, data); }, timeout);\n      } else {\n        data.timeout = timeout;\n      }\n      return;\n    }\n\n    // Otherwise, clear the autoselect timeout.\n    data.timeout = -1;\n\n    // Map the position to virtual coordinates.\n    let { vx, vy } = grid.mapToVirtual(event.clientX, event.clientY);\n\n    // Clamp the coordinates to the limits.\n    vx = Math.max(0, Math.min(vx, grid.bodyWidth -1));\n    vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));\n\n    // Set up the selection variables.\n    let r1: number;\n    let c1: number;\n    let r2: number;\n    let c2: number;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Compute the selection based pressed region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r1 = data.row;\n      r2 = grid.rowAt('body', vy);\n      c1 = 0;\n      c2 = Infinity;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      r1 = 0;\n      r2 = Infinity;\n      c1 = data.column;\n      c2 = grid.columnAt('body', vx);\n    } else {\n      r1 = cursorRow;\n      r2 = grid.rowAt('body', vy);\n      c1 = cursorColumn;\n      c2 = grid.columnAt('body', vx);\n    }\n\n    // Make the selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n  }\n\n  /**\n   * Handle the mouse up event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseUp(grid: DataGrid, event: MouseEvent): void {\n    this.release();\n  }\n\n  /**\n   * Handle the mouse double click event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The mouse up event of interest.\n   */\n  onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void {\n    if (!grid.dataModel) {\n      this.release();\n      return;\n    }\n\n    // Unpack the event.\n    let { clientX, clientY } = event;\n\n    // Hit test the grid.\n    let hit = grid.hitTest(clientX, clientY);\n\n    // Unpack the hit test.\n    let { region, row, column } = hit;\n\n    if (region === 'void') {\n      this.release();\n      return;\n    }\n\n    if (region === 'body') {\n      if (grid.editable) {\n        const cell: CellEditor.CellConfig = {\n          grid: grid,\n          row: row,\n          column: column\n        };\n        grid.editorController!.edit(cell);\n      }\n    }\n\n    this.release();\n  }\n\n  /**\n   * Handle the context menu event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The context menu event of interest.\n   */\n  onContextMenu(grid: DataGrid, event: MouseEvent): void {\n    // TODO support user-defined context menus\n  }\n\n  /**\n   * Handle the wheel event for the data grid.\n   *\n   * @param grid - The data grid of interest.\n   *\n   * @param event - The wheel event of interest.\n   */\n  onWheel(grid: DataGrid, event: WheelEvent): void {\n    // Bail if a mouse press is in progress.\n    if (this._pressData) {\n      return;\n    }\n\n    // Extract the delta X and Y movement.\n    let dx = event.deltaX;\n    let dy = event.deltaY;\n\n    // Convert the delta values to pixel values.\n    switch (event.deltaMode) {\n    case 0:  // DOM_DELTA_PIXEL\n      break;\n    case 1:  // DOM_DELTA_LINE\n      let ds = grid.defaultSizes;\n      dx *= ds.columnWidth;\n      dy *= ds.rowHeight;\n      break;\n    case 2:  // DOM_DELTA_PAGE\n      dx *= grid.pageWidth;\n      dy *= grid.pageHeight;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Scroll by the desired amount.\n    grid.scrollBy(dx, dy);\n  }\n\n  /**\n   * Convert a resize handle into a cursor.\n   */\n  cursorForHandle(handle: ResizeHandle): string {\n    return Private.cursorMap[handle];\n  }\n\n  /**\n   * Get the current pressData\n   */\n  get pressData(): PressData.PressData | null {\n    return this._pressData;\n  }\n\n  private _disposed = false;\n  private _pressData: PressData.PressData | null = null;\n}\n\n/**\n* A type alias for the resize handle types.\n*/\nexport\ntype ResizeHandle = 'top' | 'left' | 'right' | 'bottom' | 'none';\n\n\n/**\n * The namespace for the pressdata.\n */\nexport\nnamespace PressData {\n  /**\n   * A type alias for the row resize data.\n   */\n  export\n  type RowResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'row-resize';\n\n    /**\n     * The row region which holds the section being resized.\n     */\n    readonly region: DataModel.RowRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client Y position of the mouse.\n     */\n    readonly clientY: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the column resize data.\n   */\n  export\n  type ColumnResizeData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'column-resize';\n\n    /**\n     * The column region which holds the section being resized.\n     */\n    readonly region: DataModel.ColumnRegion;\n\n    /**\n     * The index of the section being resized.\n     */\n    readonly index: number;\n\n    /**\n     * The original size of the section.\n     */\n    readonly size: number;\n\n    /**\n     * The original client X position of the mouse.\n     */\n    readonly clientX: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n  };\n\n  /**\n   * A type alias for the select data.\n   */\n  export\n  type SelectData = {\n    /**\n     * The descriminated type for the data.\n     */\n    readonly type: 'select';\n\n    /**\n     * The original region for the mouse press.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The original row that was selected.\n     */\n    readonly row: number;\n\n    /**\n     * The original column that was selected.\n     */\n    readonly column: number;\n\n    /**\n     * The disposable to clear the cursor override.\n     */\n    readonly override: IDisposable;\n\n    /**\n     * The current local X position of the mouse.\n     */\n    localX: number;\n\n    /**\n     * The current local Y position of the mouse.\n     */\n    localY: number;\n\n    /**\n     * The timeout delay for the autoselect loop.\n     */\n    timeout: number;\n  };\n\n  /**\n   * A type alias for the resize handler press data.\n   */\n  export\n  type PressData = RowResizeData | ColumnResizeData | SelectData ;\n}\n\n/**\n * The namespace for the module implementation details.\n */\nexport\nnamespace Private {\n  /**\n   * Get the resize handle for a grid hit test.\n   */\n  export\n  function resizeHandleForHitTest(hit: DataGrid.HitTestResult): ResizeHandle {\n    // Fetch the row and column.\n    let r = hit.row;\n    let c = hit.column;\n\n    // Fetch the leading and trailing sizes.\n    let lw = hit.x;\n    let lh = hit.y;\n    let tw = hit.width - hit.x;\n    let th = hit.height - hit.y;\n\n    // Set up the result variable.\n    let result: ResizeHandle;\n\n    // Dispatch based on hit test region.\n    switch (hit.region) {\n    case 'corner-header':\n      if (c > 0 && lw <= 5) {\n        result = 'left';\n      } else if (tw <= 6) {\n        result = 'right';\n      } else if (r > 0 && lh <= 5) {\n        result = 'top';\n      } else if (th <= 6) {\n        result = 'bottom';\n      } else {\n        result = 'none';\n      }\n      break;\n    case 'column-header':\n      if (c > 0 && lw <= 5) {\n        result = 'left';\n      } else if (tw <= 6) {\n        result = 'right';\n      } else if (r > 0 && lh <= 5) {\n        result = 'top';\n      } else if (th <= 6) {\n        result = 'bottom';\n      } else {\n        result = 'none';\n      }\n      break;\n    case 'row-header':\n      if (c > 0 && lw <= 5) {\n        result = 'left';\n      } else if (tw <= 6) {\n        result = 'right';\n      } else if (r > 0 && lh <= 5) {\n        result = 'top';\n      } else if (th <= 6) {\n        result = 'bottom';\n      } else {\n        result = 'none';\n      }\n      break;\n    case 'body':\n      result = 'none';\n      break;\n    case 'void':\n      result = 'none';\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Return the result.\n    return result;\n  }\n\n  /**\n   * A timer callback for the autoselect loop.\n   *\n   * @param grid - The datagrid of interest.\n   *\n   * @param data - The select data of interest.\n   */\n  export\n  function autoselect(grid: DataGrid, data: PressData.SelectData): void {\n    // Bail early if the timeout has been reset.\n    if (data.timeout < 0) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let model = grid.selectionModel;\n\n    // Bail early if the selection model has been removed.\n    if (!model) {\n      return;\n    }\n\n    // Fetch the current selection.\n    let cs = model.currentSelection();\n\n    // Bail early if there is no current selection.\n    if (!cs) {\n      return;\n    }\n\n    // Fetch local X and Y coordinates of the mouse.\n    let lx = data.localX;\n    let ly = data.localY;\n\n    // Set up the selection variables.\n    let r1 = cs.r1;\n    let c1 = cs.c1;\n    let r2 = cs.r2;\n    let c2 = cs.c2;\n    let cursorRow = model.cursorRow;\n    let cursorColumn = model.cursorColumn;\n    let clear: SelectionModel.ClearMode = 'current';\n\n    // Fetch the grid geometry.\n    let hw = grid.headerWidth;\n    let hh = grid.headerHeight;\n    let vpw = grid.viewportWidth;\n    let vph = grid.viewportHeight;\n\n    // Fetch the selection mode.\n    let mode = model.selectionMode;\n\n    // Update the selection based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n    } else if (data.region === 'column-header' || mode === 'column') {\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    } else {\n      r2 += ly <= hh ? -1 : ly >= vph ? 1 : 0;\n      c2 += lx <= hw ? -1 : lx >= vpw ? 1 : 0;\n    }\n\n    // Update the current selection.\n    model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });\n\n    // Re-fetch the current selection.\n    cs = model.currentSelection();\n\n    // Bail if there is no selection.\n    if (!cs) {\n      return\n    }\n\n    // Scroll the grid based on the hit region.\n    if (data.region === 'row-header' || mode === 'row') {\n      grid.scrollToRow(cs.r2);\n    } else if (data.region === 'column-header' || mode == 'column') {\n      grid.scrollToColumn(cs.c2);\n    } else if (mode === 'cell') {\n      grid.scrollToCell(cs.r2, cs.c2);\n    }\n\n    // Schedule the next call with the current timeout.\n    setTimeout(() => { autoselect(grid, data); }, data.timeout);\n  }\n\n  /**\n   * Compute the scroll timeout for the given delta distance.\n   *\n   * @param delta - The delta pixels from the origin.\n   *\n   * @returns The scaled timeout in milliseconds.\n   */\n  export\n  function computeTimeout(delta: number): number {\n    return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);\n  }\n\n  /**\n   * A mapping of resize handle to cursor.\n   */\n  export\n  const cursorMap = {\n    top: 'ns-resize',\n    left: 'ew-resize',\n    right: 'ew-resize',\n    bottom: 'ns-resize',\n    none: 'default'\n  };\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IIterator, some\n} from '@lumino/algorithm';\n\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\nimport {\n  DataModel\n} from './datamodel';\n\n\n/**\n * A base class for creating data grid selection models.\n *\n * #### Notes\n * If the predefined selection models are insufficient for a particular\n * use case, a custom model can be defined which derives from this class.\n */\nexport\nabstract class SelectionModel {\n  /**\n   * Construct a new selection model.\n   *\n   * @param options - The options for initializing the model.\n   */\n  constructor(options: SelectionModel.IOptions) {\n    this.dataModel = options.dataModel;\n    this._selectionMode = options.selectionMode || 'cell';\n    this.dataModel.changed.connect(this.onDataModelChanged, this);\n  }\n\n  /**\n   * Whether the selection model is empty.\n   *\n   * #### Notes\n   * An empty selection model will yield an empty `selections` iterator.\n   */\n  abstract readonly isEmpty: boolean;\n\n  /**\n   * The row index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorRow: number;\n\n  /**\n   * The column index of the cursor.\n   *\n   * This is `-1` if the selection model is empty.\n   */\n  abstract readonly cursorColumn: number;\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   * \n   * @param direction - The direction of the movement.\n   */\n  abstract moveCursorWithinSelections(direction: SelectionModel.CursorMoveDirection): void;\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  abstract currentSelection(): SelectionModel.Selection | null;\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the selections in the model.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  abstract selections(): IIterator<SelectionModel.Selection>;\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  abstract select(args: SelectionModel.SelectArgs): void;\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  abstract clear(): void;\n\n  /**\n   * A signal emitted when the selection model has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * The data model associated with the selection model.\n   */\n  readonly dataModel: DataModel;\n\n  /**\n   * Get the selection mode for the model.\n   */\n  get selectionMode(): SelectionModel.SelectionMode {\n    return this._selectionMode;\n  }\n\n  /**\n   * Set the selection mode for the model.\n   *\n   * #### Notes\n   * This will clear the selection model.\n   */\n  set selectionMode(value: SelectionModel.SelectionMode) {\n    // Bail early if the mode does not change.\n    if (this._selectionMode === value) {\n      return;\n    }\n\n    // Update the internal mode.\n    this._selectionMode = value;\n\n    // Clear the current selections.\n    this.clear();\n  }\n\n  /**\n   * Test whether any selection intersects a row.\n   *\n   * @param index - The row index of interest.\n   *\n   * @returns Whether any selection intersects the row.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isRowSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsRow(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a column.\n   *\n   * @param index - The column index of interest.\n   *\n   * @returns Whether any selection intersects the column.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isColumnSelected(index: number): boolean {\n    return some(this.selections(), s => Private.containsColumn(s, index));\n  }\n\n  /**\n   * Test whether any selection intersects a cell.\n   *\n   * @param row - The row index of interest.\n   *\n   * @param column - The column index of interest.\n   *\n   * @returns Whether any selection intersects the cell.\n   *\n   * #### Notes\n   * This method may be reimplemented in a subclass.\n   */\n  isCellSelected(row: number, column: number): boolean {\n    return some(this.selections(), s => Private.containsCell(s, row, column));\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   *\n   * #### Notes\n   * Selection model implementations should update their selections\n   * in a manner that is relevant for the changes to the data model.\n   *\n   * The default implementation of this method is a no-op.\n   */\n  protected onDataModelChanged(sender: DataModel, args: DataModel.ChangedArgs): void { }\n\n  /**\n   * Emit the `changed` signal for the selection model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the selection model\n   * has changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(): void {\n    this._changed.emit(undefined);\n  }\n\n  private _changed = new Signal<this, void>(this);\n  private _selectionMode: SelectionModel.SelectionMode = 'cell';\n}\n\n\n/**\n * The namespace for the `SelectionModel` class statics.\n */\nexport\nnamespace SelectionModel {\n  /**\n   * A type alias for the selection mode.\n   */\n  export\n  type SelectionMode = 'row' | 'column' | 'cell';\n  \n  /**\n   * A type alias for the cursor move direction.\n   */\n  export type CursorMoveDirection = 'up' | 'down' | 'left' | 'right' | 'none';\n\n  /**\n   * A type alias for the clear mode.\n   */\n  export\n  type ClearMode = 'all' | 'current' | 'none';\n\n  /**\n   * A type alias for the select args.\n   */\n  export\n  type SelectArgs = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    c2: number;\n\n    /**\n     * The row index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorRow: number;\n\n    /**\n     * The column index for the cursor.\n     *\n     * This should be contained within the selection.\n     */\n    cursorColumn: number;\n\n    /**\n     * Which of the existing selections to clear.\n     */\n    clear: ClearMode;\n  };\n\n  /**\n   * A type alias for a selection in a selection model.\n   */\n  export\n  type Selection = {\n    /**\n     * The first row of the selection.\n     *\n     * This may be greater than `r2`.\n     */\n    readonly r1: number;\n\n    /**\n     * The first column of the selection.\n     *\n     * This may be greater than `c2`.\n     */\n    readonly c1: number;\n\n    /**\n     * The last row of the selection.\n     *\n     * This may be less than `r1`.\n     */\n    readonly r2: number;\n\n    /**\n     * The last column of the selection.\n     *\n     * This may be less than `c1`.\n     */\n    readonly c2: number;\n  };\n\n  /**\n   * An options object for initializing a selection model.\n   */\n  export\n  interface IOptions {\n    /**\n     * The data model for the selection model.\n     */\n    dataModel: DataModel;\n\n    /**\n     * The selection mode for the model.\n     *\n     * The default is `'cell'`.\n     */\n    selectionMode?: SelectionMode;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Test whether a selection contains a given row.\n   */\n  export\n  function containsRow(selection: SelectionModel.Selection, row: number): boolean {\n    let { r1, r2 } = selection;\n    return (row >= r1 && row <= r2) || (row >= r2 && row <= r1);\n  }\n\n  /**\n   * Test whether a selection contains a given column.\n   */\n  export\n  function containsColumn(selection: SelectionModel.Selection, column: number): boolean {\n    let { c1, c2 } = selection;\n    return (column >= c1 && column <= c2) || (column >= c2 && column <= c1);\n  }\n\n  /**\n   * Test whether a selection contains a given cell.\n   */\n  export\n  function containsCell(selection: SelectionModel.Selection, row: number, column: number): boolean {\n    return containsRow(selection, row) && containsColumn(selection, column);\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IIterator, iter\n} from '@lumino/algorithm';\n\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\n\n/**\n * A basic selection model implementation.\n *\n * #### Notes\n * This selection model is sufficient for most use cases where\n * structural knowledge of the data source is *not* required.\n */\nexport\nclass BasicSelectionModel extends SelectionModel {\n  /**\n   * Wether the selection model is empty.\n   */\n  get isEmpty(): boolean {\n    return this._selections.length === 0;\n  }\n\n  /**\n   * The row index of the cursor.\n   */\n  get cursorRow(): number {\n    return this._cursorRow;\n  }\n\n  /**\n   * The column index of the cursor.\n   */\n  get cursorColumn(): number {\n    return this._cursorColumn;\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   * \n   * @param direction - The direction of the movement.\n   */\n  moveCursorWithinSelections(direction: SelectionModel.CursorMoveDirection): void {\n    // Bail early if there are no selections or no existing cursor\n    if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {\n      return;\n    }\n\n    // Bail early if only single cell is selected\n    const firstSelection = this._selections[0];\n    if (this._selections.length === 1 &&\n      firstSelection.r1 === firstSelection.r2 &&\n      firstSelection.c1 === firstSelection.c2) {\n      return;\n    }\n\n    // start from last selection rectangle\n    if (this._cursorRectIndex === -1) {\n      this._cursorRectIndex = this._selections.length - 1;\n    }\n\n    let cursorRect = this._selections[this._cursorRectIndex];\n    const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n    const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n    let newRow = this._cursorRow + dr;\n    let newColumn = this._cursorColumn + dc;\n    const r1 = Math.min(cursorRect.r1, cursorRect.r2);\n    const r2 = Math.max(cursorRect.r1, cursorRect.r2);\n    const c1 = Math.min(cursorRect.c1, cursorRect.c2);\n    const c2 = Math.max(cursorRect.c1, cursorRect.c2);\n\n    const moveToNextRect = () => {\n      this._cursorRectIndex = (this._cursorRectIndex + 1) % this._selections.length;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.min(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.min(cursorRect.c1, cursorRect.c2);\n    };\n    \n    const moveToPreviousRect = () => {\n      this._cursorRectIndex = this._cursorRectIndex === 0 ? this._selections.length - 1 : this._cursorRectIndex - 1;\n      cursorRect = this._selections[this._cursorRectIndex];\n      newRow = Math.max(cursorRect.r1, cursorRect.r2);\n      newColumn = Math.max(cursorRect.c1, cursorRect.c2);\n    };\n\n    if (newRow > r2) {\n      newRow = r1;\n      newColumn += 1;\n      if (newColumn > c2) {\n        moveToNextRect();\n      }\n    } else if (newRow < r1) {\n      newRow = r2;\n      newColumn -= 1;\n      if (newColumn < c1) {\n        moveToPreviousRect();\n      }\n    } else if (newColumn > c2) {\n      newColumn = c1;\n      newRow += 1;\n      if (newRow > r2) {\n        moveToNextRect();\n      }\n    } else if (newColumn < c1) {\n      newColumn = c2;\n      newRow -= 1;\n      if (newRow < r1) {\n        moveToPreviousRect();\n      }\n    }\n\n    this._cursorRow = newRow;\n    this._cursorColumn = newColumn;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Get the current selection in the selection model.\n   *\n   * @returns The current selection or `null`.\n   *\n   * #### Notes\n   * This is the selection which holds the cursor.\n   */\n  currentSelection(): SelectionModel.Selection | null {\n    return this._selections[this._selections.length - 1] || null;\n  }\n\n  /**\n   * Get an iterator of the selections in the model.\n   *\n   * @returns A new iterator of the current selections.\n   *\n   * #### Notes\n   * The data grid will render the selections in order.\n   */\n  selections(): IIterator<SelectionModel.Selection> {\n    return iter(this._selections);\n  }\n\n  /**\n   * Select the specified cells.\n   *\n   * @param args - The arguments for the selection.\n   */\n  select(args: SelectionModel.SelectArgs): void {\n    // Fetch the current row and column counts;\n    let rowCount = this.dataModel.rowCount('body');\n    let columnCount = this.dataModel.columnCount('body');\n\n    // Bail early if there is no content.\n    if (rowCount <= 0 || columnCount <= 0) {\n      return;\n    }\n\n    // Unpack the arguments.\n    let { r1, c1, r2, c2, cursorRow, cursorColumn, clear } = args;\n\n    // Clear the necessary selections.\n    if (clear === 'all') {\n      this._selections.length = 0;\n    } else if (clear === 'current') {\n      this._selections.pop();\n    }\n\n    // Clamp to the data model bounds.\n    r1 = Math.max(0, Math.min(r1, rowCount - 1));\n    r2 = Math.max(0, Math.min(r2, rowCount - 1));\n    c1 = Math.max(0, Math.min(c1, columnCount - 1));\n    c2 = Math.max(0, Math.min(c2, columnCount - 1));\n\n    // Handle the selection mode.\n    if (this.selectionMode === 'row') {\n      c1 = 0;\n      c2 = columnCount - 1;\n    } else if (this.selectionMode === 'column') {\n      r1 = 0;\n      r2 = rowCount - 1;\n    }\n\n    // Alias the cursor row and column.\n    let cr = cursorRow;\n    let cc = cursorColumn;\n\n    // Compute the new cursor location.\n    if (cr < 0 || (cr < r1 && cr < r2) || (cr > r1 && cr > r2)) {\n      cr = r1;\n    }\n    if (cc < 0 || (cc < c1 && cc < c2) || (cc > c1 && cc > c2)) {\n      cc = c1;\n    }\n\n    // Update the cursor.\n    this._cursorRow = cr;\n    this._cursorColumn = cc;\n    this._cursorRectIndex = this._selections.length;\n\n    // Add the new selection.\n    this._selections.push({ r1, c1, r2, c2 });\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * Clear all selections in the selection model.\n   */\n  clear(): void {\n    // Bail early if there are no selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Reset the internal state.\n    this._cursorRow = -1;\n    this._cursorColumn = -1;\n    this._cursorRectIndex = -1;\n    this._selections.length = 0;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   *\n   * @param args - The arguments for the signal.\n   */\n  protected onDataModelChanged(sender: DataModel, args: DataModel.ChangedArgs): void {\n    // Bail early if the model has no current selections.\n    if (this._selections.length === 0) {\n      return;\n    }\n\n    // Bail early if the cells have changed in place.\n    if (args.type === 'cells-changed') {\n      return;\n    }\n\n    // Bail early if there is no change to the row or column count.\n    if (args.type === 'rows-moved' || args.type === 'columns-moved') {\n      return;\n    }\n\n    // Fetch the last row and column index.\n    let lr = sender.rowCount('body') - 1;\n    let lc = sender.columnCount('body') - 1;\n\n    // Bail early if the data model is empty.\n    if (lr < 0 || lc < 0) {\n      this._selections.length = 0;\n      this.emitChanged();\n      return;\n    }\n\n    // Fetch the selection mode.\n    let mode = this.selectionMode;\n\n    // Set up the assignment index variable.\n    let j = 0;\n\n    // Iterate over the current selections.\n    for (let i = 0, n = this._selections.length; i < n; ++i) {\n      // Unpack the selection.\n      let { r1, c1, r2, c2 } = this._selections[i];\n\n      // Skip the selection if it will disappear.\n      if ((lr < r1 && lr < r2) || (lc < c1 && lc < c2)) {\n        continue;\n      }\n\n      // Modify the bounds based on the selection mode.\n      if (mode === 'row') {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = 0;\n        c2 = lc;\n      } else if (mode === 'column') {\n        r1 = 0;\n        r2 = lr;\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      } else {\n        r1 = Math.max(0, Math.min(r1, lr));\n        r2 = Math.max(0, Math.min(r2, lr));\n        c1 = Math.max(0, Math.min(c1, lc));\n        c2 = Math.max(0, Math.min(c2, lc));\n      }\n\n      // Assign the modified selection to the array.\n      this._selections[j++] = { r1, c1, r2, c2 };\n    }\n\n    // Remove the stale selections.\n    this._selections.length = j;\n\n    // Emit the changed signal.\n    this.emitChanged();\n  }\n\n  private _cursorRow = -1;\n  private _cursorColumn = -1;\n  private _cursorRectIndex = -1;\n  private _selections: SelectionModel.Selection[] = [];\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  GraphicsContext\n} from './graphicscontext';\n\n\n/**\n * An object which renders the cells of a data grid.\n *\n * #### Notes\n * If the predefined cell renderers are insufficient for a particular\n * use case, a custom cell renderer can be defined which derives from\n * this class.\n *\n * The data grid renders cells in column-major order, by region. The\n * region order is: body, row header, column header, corner header.\n */\nexport\nabstract class CellRenderer {\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   *\n   * #### Notes\n   * The grid will save/restore the `gc` state before/after invoking\n   * the renderer.\n   *\n   * For performance, the cell content is efficiently clipped to the\n   * width of the column, but *the height is not clipped*. If height\n   * clipping is needed, the renderer must set up its own clip rect.\n   *\n   * The renderer **must not** draw outside the cell bounding height.\n   */\n  abstract paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void;\n}\n\n\n/**\n * The namespace for the `CellRenderer` class statics.\n */\nexport\nnamespace CellRenderer {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export\n  type CellConfig = {\n    /**\n     * The X position of the cell rectangle, in viewport coordinates.\n     */\n    readonly x: number;\n\n    /**\n     * The Y position of the cell rectangle, in viewport coordinates.\n     */\n    readonly y: number;\n\n    /**\n     * The height of the cell rectangle, in viewport pixels.\n     */\n    readonly height: number;\n\n    /**\n     * The width of the cell rectangle, in viewport pixels.\n     */\n    readonly width: number;\n\n    /**\n     * The region for the cell.\n     */\n    readonly region: DataModel.CellRegion;\n\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n\n    /**\n     * The value for the cell.\n     */\n    readonly value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    readonly metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a cell renderer config function.\n   *\n   * This type is used to compute a value from a cell config object.\n   */\n  export\n  type ConfigFunc<T> = (config: CellConfig) => T;\n\n  /**\n   * A type alias for a cell renderer config option.\n   *\n   * A config option can be a static value or a config function.\n   */\n  export\n  type ConfigOption<T> = T | ConfigFunc<T>;\n\n  /**\n   * Resolve a config option for a cell renderer.\n   *\n   * @param option - The config option to resolve.\n   *\n   * @param config - The cell config object.\n   *\n   * @returns The resolved value for the option.\n   */\n  export\n  function resolveOption<T>(option: ConfigOption<T>, config: CellConfig): T {\n    return typeof option === 'function' ? (option as ConfigFunc<T>)(config) : option;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n\nimport {\n  Message\n} from '@lumino/messaging';\n\nimport {\n  Widget\n} from '@lumino/widgets';\n\n\n/**\n * A widget which implements a notification popup.\n */\nexport\nclass Notification extends Widget {\n  /**\n   * Construct a new notification.\n   *\n   * @param options - The options for initializing the notification.\n   */\n  constructor(options: Notification.IOptions) {\n    super({ node: Private.createNode() });\n    this.addClass('lm-DataGrid-notification');\n    this.setFlag(Widget.Flag.DisallowLayout);\n\n    this._target = options.target;\n    this._message = options.message || '';\n    this._placement = options.placement || 'bottom';\n\n    Widget.attach(this, document.body);\n\n    if (options.timeout && options.timeout > 0) {\n      setTimeout(() => {\n        this.close();\n      }, options.timeout);\n    }\n  }\n\n  /**\n   * Handle the DOM events for the notification.\n   *\n   * @param event - The DOM event sent to the notification.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the notification's DOM node.\n   *\n   * This should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n    case 'mousedown':\n      this._evtMouseDown(event as MouseEvent);\n      break;\n    case 'contextmenu':\n      event.preventDefault();\n      event.stopPropagation();\n      break;\n    }\n  }\n\n  /**\n   * Get the placement of the notification.\n   */\n  get placement(): Notification.Placement {\n    return this._placement;\n  }\n\n  /**\n   * Set the placement of the notification.\n   */\n  set placement(value: Notification.Placement) {\n    // Do nothing if the placement does not change.\n    if (this._placement === value) {\n      return;\n    }\n\n    // Update the internal placement.\n    this._placement = value;\n\n    // Schedule an update for notification.\n    this.update();\n  }\n\n  /**\n   * Get the current value of the message.\n   */\n  get message(): string {\n    return this._message;\n  }\n\n  /**\n   * Set the current value of the message.\n   *\n   */\n  set message(value: string) {\n    // Do nothing if the value does not change.\n    if (this._message === value) {\n      return;\n    }\n\n    // Update the internal value.\n    this._message = value;\n\n    // Schedule an update for notification.\n    this.update();\n  }\n\n  /**\n   * Get the node presenting the message.\n   */\n  get messageNode(): HTMLSpanElement {\n    return this.node.getElementsByClassName('lm-DataGrid-notificationMessage')[0] as HTMLSpanElement;\n  }\n\n  /**\n   * A method invoked on a 'before-attach' message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    this.node.addEventListener('mousedown', this);\n    this.update();\n  }\n\n  /**\n   * A method invoked on an 'after-detach' message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    this.node.removeEventListener('mousedown', this);\n  }\n\n  /**\n   * A method invoked on an 'update-request' message.\n   */\n  protected onUpdateRequest(msg: Message): void {\n    const targetRect = this._target.getBoundingClientRect();\n    const style = this.node.style;\n\n    switch (this._placement) {\n      case 'bottom':\n        style.left = targetRect.left + 'px';\n        style.top = targetRect.bottom + 'px';\n        break;\n      case 'top':\n        style.left = targetRect.left + 'px';\n        style.height = targetRect.top + 'px';\n        style.top = '0';\n        style.alignItems = 'flex-end';\n        style.justifyContent = 'flex-end';\n        break;\n      case 'left':\n        style.left = '0';\n        style.width = targetRect.left + 'px';\n        style.top = targetRect.top + 'px';\n        style.alignItems = 'flex-end';\n        style.justifyContent = 'flex-end';\n        break;\n      case 'right':\n        style.left = targetRect.right + 'px';\n        style.top = targetRect.top + 'px';\n        break;\n    }\n\n    this.messageNode.innerHTML = this._message;\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the notification.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Do nothing if it's not a left mouse press.\n    if (event.button !== 0) {\n      return;\n    }\n\n    event.preventDefault();\n    event.stopPropagation();\n    this.close();\n  }\n\n  private _target: HTMLElement;\n  private _message: string = '';\n  private _placement: Notification.Placement;\n}\n\n\n/**\n * The namespace for the `Notification` class statics.\n */\nexport\nnamespace Notification {\n  /**\n   * A type alias for a notification placement.\n   */\n  export\n  type Placement = 'top' | 'bottom' | 'left' | 'right';\n\n  /**\n   * An options object for creating a notification.\n   */\n  export\n  interface IOptions {\n    /**\n     * Target element to attach notification to.\n     *\n     */\n    target: HTMLElement;\n\n    /**\n     * The message to show on notification.\n     */\n    message?: string;\n\n    /**\n     * The placement of the notification.\n     *\n     * The default is `'bottom'`.\n     */\n    placement?: Placement;\n\n    /**\n     * Duration in ms after which to close notification popup.\n     *\n     * The default is undefined, and notification is kept visible\n     * Timeout value needs to be greater than zero\n     */\n    timeout?: number;\n  }\n}\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * Create the DOM node for notification.\n   */\n  export\n  function createNode(): HTMLElement {\n    const node = document.createElement('div');\n    const container = document.createElement('div');\n    container.className = 'lm-DataGrid-notificationContainer';\n    const message = document.createElement('span');\n    message.className = 'lm-DataGrid-notificationMessage';\n    container.appendChild(message);\n    node.appendChild(container);\n\n    return node;\n  }\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\nimport {\n  DataGrid\n} from './datagrid';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  getKeyboardLayout\n} from '@lumino/keyboard';\n\nimport {\n  Signal\n} from '@lumino/signaling';\n\nimport {\n  Notification\n} from './notification';\n\n/**\n * A response object returned from cell input validator\n */\nexport\ninterface ICellInputValidatorResponse {\n  /**\n   * Flag indicating cell input is valid or not\n   */\n  valid: boolean;\n  /**\n   * Validation error message. Set only when input is invalid\n   */\n  message?: string;\n}\n\n/**\n * An object which validates cell input values.\n */\nexport\ninterface ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: any): ICellInputValidatorResponse;\n}\n\n/**\n * An object returned from cell editor after a successful edit.\n */\nexport\ninterface ICellEditResponse {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  cell: CellEditor.CellConfig;\n  /**\n   * Value input.\n   */\n  value: any;\n  /**\n   * Cursor move direction based on keys pressed to end the edit.\n   */\n  cursorMovement: SelectionModel.CursorMoveDirection;\n}\n\n/**\n * An object implementing cell editing.\n */\nexport\ninterface ICellEditor {\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void;\n  /**\n   * Cancel editing the cell.\n   */\n  cancel(): void;\n}\n\n// default validation error message\nconst DEFAULT_INVALID_INPUT_MESSAGE = \"Invalid input!\";\n\n// A type alias for available cell data types\nexport\ntype CellDataType = 'string' | 'number' | 'integer' | 'boolean' | 'date' |\n                    'string:option' | 'number:option' | 'integer:option'| 'date:option'|\n                    'string:dynamic-option' | 'number:dynamic-option' | 'integer:dynamic-option' | 'date:dynamic-option';\n\n/**\n * An object containing cell editing options.\n */\nexport\ninterface ICellEditOptions {\n  /**\n   * Cell editor to use for editing.\n   * \n   * #### Notes\n   * This object is only used by cell editor controller.\n   * If not set, controller picks the most suitable editor\n   * for the particular cell configuration.\n   */\n  editor?: ICellEditor;\n  /**\n   * Cell input validator to use for value validation.\n   */\n  validator?: ICellInputValidator;\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  onCancel?: () => void;\n}\n\n/**\n * A cell input validator object which always returns valid.\n */\nexport\nclass PassInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: any): ICellInputValidatorResponse {\n    return { valid: true };\n  }\n}\n\n/**\n * Text cell input validator.\n */\nexport\nclass TextInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: string): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (typeof value !== 'string') {\n      return {\n        valid: false,\n        message: 'Input must be valid text'\n      };\n    }\n\n    if (!isNaN(this.minLength) && value.length < this.minLength) {\n      return {\n        valid: false,\n        message: `Text length must be greater than ${this.minLength}`\n      };\n    }\n\n    if (!isNaN(this.maxLength) && value.length > this.maxLength) {\n      return {\n        valid: false,\n        message: `Text length must be less than ${this.maxLength}`\n      };\n    }\n\n    if (this.pattern && !this.pattern.test(value)) {\n      return {\n        valid: false,\n        message: `Text doesn't match the required pattern`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum text length\n   * \n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  minLength: number = Number.NaN;\n  /**\n   * Maximum text length\n   * \n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  maxLength: number = Number.NaN;\n  /**\n   * Required text pattern as regular expression\n   * \n   * The default is null, meaning no pattern constraint\n   */\n  pattern: RegExp | null = null;\n}\n\n/**\n * Integer cell input validator.\n */\nexport\nclass IntegerInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: number): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value) || (value % 1 !== 0)) {\n      return {\n        valid: false,\n        message: 'Input must be valid integer'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   * \n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   * \n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n/**\n * Real number cell input validator.\n */\nexport\nclass NumberInputValidator implements ICellInputValidator {\n  /**\n   * Validate cell input.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param value - The cell value input.\n   *\n   * @returns An object with validation result.\n   */\n  validate(cell: CellEditor.CellConfig, value: number): ICellInputValidatorResponse {\n    if (value === null) {\n      return { valid: true };\n    }\n\n    if (isNaN(value)) {\n      return {\n        valid: false,\n        message: 'Input must be valid number'\n      };\n    }\n\n    if (!isNaN(this.min) && value < this.min) {\n      return {\n        valid: false,\n        message: `Input must be greater than ${this.min}`\n      };\n    }\n\n    if (!isNaN(this.max) && value > this.max) {\n      return {\n        valid: false,\n        message: `Input must be less than ${this.max}`\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Minimum value\n   * \n   * The default is Number.NaN, meaning no minimum constraint\n   */\n  min: number = Number.NaN;\n  /**\n   * Maximum value\n   * \n   * The default is Number.NaN, meaning no maximum constraint\n   */\n  max: number = Number.NaN;\n}\n\n\n/**\n * An abstract base class that provides the most of the functionality\n * needed by a cell editor. All of the built-in cell editors\n * for various cell types are derived from this base class. Custom cell editors\n * can be easily implemented by extending this class.\n */\nexport\nabstract class CellEditor implements ICellEditor, IDisposable {\n  /**\n   * Construct a new cell editor.\n   */\n  constructor() {\n    this.inputChanged.connect(() => {\n      this.validate();\n    });\n  }\n\n  /**\n   * Whether the cell editor is disposed.\n   */\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose(): void {\n    if (this._disposed) {\n      return;\n    }\n\n    if (this._gridWheelEventHandler) {\n      this.cell.grid.node.removeEventListener('wheel', this._gridWheelEventHandler);\n      this._gridWheelEventHandler = null;\n    }\n\n    this._closeValidityNotification();\n\n    this._disposed = true;\n    this.cell.grid.node.removeChild(this.viewportOccluder);\n  }\n\n  /**\n   * Start editing the cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): void {\n    this.cell = cell;\n    this.onCommit = options && options.onCommit;\n    this.onCancel = options && options.onCancel;\n\n    this.validator = (options && options.validator) ? options.validator : this.createValidatorBasedOnType();\n\n    this._gridWheelEventHandler = () => {\n      this._closeValidityNotification();\n      this.updatePosition();\n    };\n\n    cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);\n\n    this._addContainer();\n\n    this.updatePosition();\n    this.startEditing();\n  }\n\n  /**\n   * Cancel editing the cell.\n   */\n  cancel() {\n    if (this._disposed) {\n      return;\n    }\n\n    this.dispose();\n    if (this.onCancel) {\n      this.onCancel();\n    }\n  }\n\n  /**\n   * Start editing the cell. Usually an editor widget is created and\n   *  added to `editorContainer`\n   */\n  protected abstract startEditing(): void;\n  /**\n   * Return the current input entered. This method throws exceptions\n   * if input is invalid. Error message in exception is shown as notification.\n   */\n  protected abstract getInput(): any;\n\n  /**\n   * Whether the value input is valid.\n   */\n  protected get validInput(): boolean {\n    return this._validInput;\n  }\n\n  /**\n   * Validate the cell input. Shows validation error notification when input is invalid.\n   */\n  protected validate() {\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);\n      return;\n    }\n\n    if (this.validator) {\n      const result = this.validator.validate(this.cell, value);\n      if (result.valid) {\n        this.setValidity(true);\n      } else {\n        this.setValidity(false, result.message || DEFAULT_INVALID_INPUT_MESSAGE);\n      }\n    } else {\n      this.setValidity(true);\n    }\n  }\n\n  /**\n   * Set validity flag.\n   *\n   * @param valid - Whether the input is valid.\n   *\n   * @param message - Notification message to show.\n   * \n   * If message is set to empty string (which is the default)\n   * existing notification popup is removed if any.\n   */\n  protected setValidity(valid: boolean, message: string = \"\") {\n    this._validInput = valid;\n\n    this._closeValidityNotification();\n\n    if (valid) {\n      this.editorContainer.classList.remove('lm-mod-invalid');\n    } else {\n      this.editorContainer.classList.add('lm-mod-invalid');\n\n      // show a notification popup\n      if (message !== \"\") {\n        this.validityNotification = new Notification({\n          target: this.editorContainer,\n          message: message,\n          placement: 'bottom',\n          timeout: 5000\n        });\n        this.validityNotification.show();\n      }\n    }\n  }\n\n  /**\n   * Create and return a cell input validator based on configuration of the\n   * cell being edited. If no suitable validator can be found, it returns undefined.\n   */\n  protected createValidatorBasedOnType(): ICellInputValidator | undefined {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n\n    switch (metadata && metadata.type) {\n      case 'string':\n        {\n          const validator = new TextInputValidator();\n          if (typeof(metadata!.format) === 'string') {\n            const format = metadata!.format;\n            switch (format) {\n              case 'email':\n                validator.pattern = new RegExp(\"^([a-z0-9_\\.-]+)@([\\da-z\\.-]+)\\.([a-z\\.]{2,6})$\");\n                break;\n              case 'uuid':\n                validator.pattern = new RegExp(\"[0-9a-fA-F]{8}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{4}\\-[0-9a-fA-F]{12}\");\n                break;\n              case 'uri':\n                // TODO\n                break;\n              case 'binary':\n                // TODO\n                break;\n            }\n          }\n\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minLength !== undefined) {\n              validator.minLength = metadata!.constraint.minLength;\n            }\n            if (metadata!.constraint.maxLength !== undefined) {\n              validator.maxLength = metadata!.constraint.maxLength;\n            }\n            if (typeof(metadata!.constraint.pattern) === 'string') {\n              validator.pattern = new RegExp(metadata!.constraint.pattern);\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'number':\n        {\n          const validator = new NumberInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n      case 'integer':\n        {\n          const validator = new IntegerInputValidator();\n          if (metadata!.constraint) {\n            if (metadata!.constraint.minimum !== undefined) {\n              validator.min = metadata!.constraint.minimum;\n            }\n            if (metadata!.constraint.maximum !== undefined) {\n              validator.max = metadata!.constraint.maximum;\n            }\n          }\n          return validator;\n        }\n        break;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Compute cell rectangle and return with other cell properties.\n   */\n  protected getCellInfo(cell: CellEditor.CellConfig): Private.ICellInfo {\n    const { grid, row, column } = cell;\n    const data = grid.dataModel!.data('body', row, column);\n\n    const columnX = grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);\n    const rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);\n    const width = grid.columnSize('body', column);\n    const height = grid.rowSize('body', row);\n\n    return {\n      grid: grid,\n      row: row,\n      column: column,\n      data: data,\n      x: columnX,\n      y: rowY,\n      width: width,\n      height: height\n    };\n  }\n\n  /**\n   * Reposition cell editor by moving viewport occluder and cell editor container.\n   */\n  protected updatePosition(): void {\n    const grid = this.cell.grid;\n    const cellInfo = this.getCellInfo(this.cell);\n    const headerHeight = grid.headerHeight;\n    const headerWidth = grid.headerWidth;\n\n    this.viewportOccluder.style.top = headerHeight + 'px';\n    this.viewportOccluder.style.left = headerWidth + 'px';\n    this.viewportOccluder.style.width = (grid.viewportWidth - headerWidth) + 'px';\n    this.viewportOccluder.style.height = (grid.viewportHeight - headerHeight) + 'px';\n    this.viewportOccluder.style.position = 'absolute';\n\n    this.editorContainer.style.left = (cellInfo.x - 1 - headerWidth) + 'px';\n    this.editorContainer.style.top = (cellInfo.y - 1 - headerHeight) + 'px';\n    this.editorContainer.style.width = (cellInfo.width + 1) + 'px';\n    this.editorContainer.style.height = (cellInfo.height + 1) + 'px';\n    this.editorContainer.style.visibility = 'visible';\n    this.editorContainer.style.position = 'absolute';\n  }\n\n  /**\n   * Commit the edited value.\n   * \n   * @param cursorMovement - Cursor move direction based on keys pressed to end the edit.\n   * \n   * @returns true on valid input, false otherwise.\n   */\n  protected commit(cursorMovement: SelectionModel.CursorMoveDirection = 'none'): boolean {\n    this.validate();\n\n    if (!this._validInput) {\n      return false;\n    }\n\n    let value;\n    try {\n      value = this.getInput();\n    } catch (error) {\n      console.log(`Input error: ${error.message}`);\n      return false;\n    }\n\n    this.dispose();\n\n    if (this.onCommit) {\n      this.onCommit({\n        cell: this.cell,\n        value: value,\n        cursorMovement: cursorMovement\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Create container elements needed to prevent editor widget overflow\n   * beyond viewport and to position cell editor widget.\n   */\n  private _addContainer() {\n    this.viewportOccluder = document.createElement('div');\n    this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';\n    this.cell.grid.node.appendChild(this.viewportOccluder);\n\n    this.editorContainer = document.createElement('div');\n    this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';\n    this.viewportOccluder.appendChild(this.editorContainer);\n\n    // update mouse event pass-through state based on input validity\n    this.editorContainer.addEventListener('mouseleave', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = this._validInput ? 'none' : 'auto';\n    });\n    this.editorContainer.addEventListener('mouseenter', (event: MouseEvent) => {\n      this.viewportOccluder.style.pointerEvents = 'none';\n    });\n  }\n\n  /**\n   * Remove validity notification popup.\n   */\n  private _closeValidityNotification() {\n    if (this.validityNotification) {\n      this.validityNotification.close();\n      this.validityNotification = null;\n    }\n  }\n\n  /**\n   * A signal emitted when input changes.\n   */\n  protected inputChanged = new Signal<this, void>(this);\n  /**\n   * Callback method to call on cell edit commit.\n   */\n  protected onCommit?: (response: ICellEditResponse) => void;\n  /**\n   * Callback method to call on cell edit cancel.\n   */\n  protected onCancel?: () => void;\n  /**\n   * Cell configuration data for the cell being edited.\n   */\n  protected cell: CellEditor.CellConfig;\n  /**\n   * Cell input validator to use for the cell being edited.\n   */\n  protected validator: ICellInputValidator | undefined;\n  /**\n   * The div element used to prevent editor widget overflow beyond grid viewport.\n   */\n  protected viewportOccluder: HTMLDivElement;\n  /**\n   * The div element used to contain and position editor widget.\n   */\n  protected editorContainer: HTMLDivElement;\n  /**\n   * Notification popup used to show validation error messages.\n   */\n  protected validityNotification: Notification | null = null;\n  /**\n   * Whether the cell editor is disposed.\n   */\n  private _disposed = false;\n  /**\n   * Whether the value input is valid.\n   */\n  private _validInput: boolean = true;\n  /**\n   * Grid wheel event handler.\n   */\n  private _gridWheelEventHandler: ((this: HTMLElement, ev: WheelEvent) => any) | null = null;\n}\n\n/**\n * Abstract base class with shared functionality\n * for cell editors which use HTML Input widget as editor.\n */\nexport\nabstract class InputCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n      case 'input':\n        this._onInput(event);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this.createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this.input.value = this.deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this.input);\n    this.input.focus();\n    this.input.select();\n\n    this.bindEvents();\n  }\n\n  protected deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  protected createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    input.spellcheck = false;\n    input.type = this.inputType;\n\n    this.input = input;\n  }\n\n  protected bindEvents() {\n    this.input.addEventListener('keydown', this);\n    this.input.addEventListener('blur', this);\n    this.input.addEventListener('input', this);\n  }\n\n  private _unbindEvents() {\n    this.input.removeEventListener('keydown', this);\n    this.input.removeEventListener('blur', this);\n    this.input.removeEventListener('input', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.input.focus();\n    }\n  }\n\n  private _onInput(event: Event) {\n    this.inputChanged.emit(void 0);\n  }\n\n  protected input: HTMLInputElement;\n  protected abstract inputType: string;\n}\n\n/**\n * Cell editor for text cells.\n */\nexport\nclass TextCellEditor extends InputCellEditor {\n  /**\n   * Return the current text input entered.\n   */\n  protected getInput(): string | null {\n    return this.input.value;\n  }\n\n  protected inputType: string = 'text';\n}\n\n/**\n * Cell editor for real number cells.\n */\nexport\nclass NumberCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    super.startEditing();\n\n    this.input.step = 'any';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current number input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    const floatValue = parseFloat(value);\n    if (isNaN(floatValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return floatValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for integer cells.\n */\nexport\nclass IntegerCellEditor extends InputCellEditor {\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    super.startEditing();\n\n    this.input.step = '1';\n\n    const cell = this.cell;\n\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    const constraint = metadata.constraint;\n    if (constraint) {\n      if (constraint.minimum) {\n        this.input.min = constraint.minimum;\n      }\n      if (constraint.maximum) {\n        this.input.max = constraint.maximum;\n      }\n    }\n  }\n\n  /**\n   * Return the current integer input entered. This method throws exception\n   * if input is invalid.\n   */\n  protected getInput(): number | null {\n    let value = this.input.value;\n    if (value.trim() === '') {\n      return null;\n    }\n\n    let intValue = parseInt(value);\n    if (isNaN(intValue)) {\n      throw new Error('Invalid input');\n    }\n\n    return intValue;\n  }\n\n  protected inputType: string = 'number';\n}\n\n/**\n * Cell editor for date cells.\n */\nexport\nclass DateCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current date input entered.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.type = 'date';\n    input.pattern = \"\\d{4}-\\d{2}-\\d{2}\";\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n/**\n * Cell editor for boolean cells.\n */\nexport\nclass BooleanCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'mousedown':\n        // fix focus loss problem in Safari and Firefox\n        this._input.focus();\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.checked = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current boolean input entered.\n   */\n  protected getInput(): boolean | null {\n    return this._input.checked;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return false;\n    }\n\n    return value == true;\n  }\n\n  private _createWidget() {\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorCheckbox');\n    input.type = 'checkbox';\n    input.spellcheck = false;\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('mousedown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('mousedown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n\n/**\n * Cell editor for option cells.\n * \n * It supports multiple option selection. If cell metadata contains\n * type attribute 'array', then it behaves as a multi select.\n * In that case cell data is expected to be list of string values.\n */\nexport\nclass OptionCellEditor extends CellEditor {\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    super.dispose();\n\n    if (this._isMultiSelect) {\n      document.body.removeChild(this._select);\n    }\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    this._isMultiSelect = metadata.type === 'array';\n    this._createWidget();\n\n    if (this._isMultiSelect) {\n      this._select.multiple = true;\n      const values = this._deserialize(cellInfo.data) as string[];\n      for (let i = 0; i < this._select.options.length; ++i) {\n        const option = this._select.options.item(i);\n        option!.selected = values.indexOf(option!.value) !== -1;\n      }\n      document.body.appendChild(this._select);\n    } else {\n      this._select.value = this._deserialize(cellInfo.data) as string;\n      this.editorContainer.appendChild(this._select);\n    }\n\n    this._select.focus();\n\n    this._bindEvents();\n\n    this.updatePosition();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | string[] | null {\n    if (this._isMultiSelect) {\n      const input: string[] = [];\n      for (let i = 0; i < this._select.selectedOptions.length; ++i) {\n        input.push(this._select.selectedOptions.item(i)!.value);\n      }\n      return input;\n    } else {\n      return this._select.value;\n    }\n  }\n\n  /**\n   * Reposition cell editor.\n   */\n  protected updatePosition(): void {\n    super.updatePosition();\n\n    if (!this._isMultiSelect) {\n      return;\n    }\n\n    const cellInfo = this.getCellInfo(this.cell);\n\n    this._select.style.position = 'absolute';\n    const editorContainerRect = this.editorContainer.getBoundingClientRect();\n\n    this._select.style.left = editorContainerRect.left + 'px';\n    this._select.style.top = (editorContainerRect.top + cellInfo.height) + 'px';\n    this._select.style.width = editorContainerRect.width + 'px';\n    this._select.style.maxHeight = '60px';\n\n    this.editorContainer.style.visibility = 'hidden';\n  }\n\n  private _deserialize(value: any): string | string[] {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    if (this._isMultiSelect) {\n      const values: string[] = [];\n      if (Array.isArray(value)) {\n        for (let item of value) {\n          values.push(item.toString());\n        }\n      }\n      return values;\n    } else {\n      return value.toString();\n    }\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    const items = metadata.constraint.enum;\n\n    const select = document.createElement('select');\n    select.classList.add('lm-DataGrid-cellEditorWidget');\n    for (let item of items) {\n      const option = document.createElement(\"option\");\n      option.value = item;\n      option.text = item;\n      select.appendChild(option);\n    }\n\n    this._select = select;\n  }\n\n  private _bindEvents() {\n    this._select.addEventListener('keydown', this._onKeyDown.bind(this));\n    this._select.addEventListener('blur', this._onBlur.bind(this));\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._select.focus();\n    }\n  }\n\n  private _select: HTMLSelectElement;\n  private _isMultiSelect: boolean = false;\n}\n\n/**\n * Cell editor for option cells whose value can be any value\n * from set of pre-defined options or values that can be input by user.\n */\nexport\nclass DynamicOptionCellEditor extends CellEditor {\n  /**\n   * Handle the DOM events for the editor.\n   *\n   * @param event - The DOM event sent to the editor.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n      case 'keydown':\n        this._onKeyDown(event as KeyboardEvent);\n        break;\n      case 'blur':\n        this._onBlur(event as FocusEvent);\n        break;\n    }\n  }\n\n  /**\n   * Dispose of the resources held by cell editor.\n   */\n  dispose() {\n    if (this.isDisposed) {\n      return;\n    }\n\n    this._unbindEvents();\n\n    super.dispose();\n  }\n\n  /**\n   * Start editing the cell.\n   */\n  protected startEditing() {\n    this._createWidget();\n\n    const cell = this.cell;\n    const cellInfo = this.getCellInfo(cell);\n    this._input.value = this._deserialize(cellInfo.data);\n    this.editorContainer.appendChild(this._input);\n    this._input.focus();\n    this._input.select();\n\n    this._bindEvents();\n  }\n\n  /**\n   * Return the current option input.\n   */\n  protected getInput(): string | null {\n    return this._input.value;\n  }\n\n  private _deserialize(value: any): any {\n    if (value === null || value === undefined) {\n      return '';\n    }\n\n    return value.toString();\n  }\n\n  private _createWidget() {\n    const cell = this.cell;\n    const grid = cell.grid;\n    const dataModel = grid.dataModel!;\n    const rowCount = dataModel.rowCount('body');\n\n    const listId = 'cell-editor-list';\n    const list = document.createElement('datalist');\n    list.id = listId;\n    const input = document.createElement('input');\n    input.classList.add('lm-DataGrid-cellEditorWidget');\n    input.classList.add('lm-DataGrid-cellEditorInput');\n    const valueSet = new Set<string>();\n    for (let r = 0; r < rowCount; ++r) {\n      const data = dataModel.data('body', r, cell.column);\n      if (data) {\n        valueSet.add(data);\n      }\n    }\n    valueSet.forEach((value: string) => {\n      const option = document.createElement(\"option\");\n      option.value = value;\n      option.text = value;\n      list.appendChild(option);\n    });\n    this.editorContainer.appendChild(list);\n    input.setAttribute('list', listId);\n\n    this._input = input;\n  }\n\n  private _bindEvents() {\n    this._input.addEventListener('keydown', this);\n    this._input.addEventListener('blur', this);\n  }\n\n  private _unbindEvents() {\n    this._input.removeEventListener('keydown', this);\n    this._input.removeEventListener('blur', this);\n  }\n\n  private _onKeyDown(event: KeyboardEvent) {\n    switch (getKeyboardLayout().keyForKeydownEvent(event)) {\n      case 'Enter':\n        this.commit(event.shiftKey ? 'up' : 'down');\n        break;\n      case 'Tab':\n        this.commit(event.shiftKey ? 'left' : 'right');\n        event.stopPropagation();\n        event.preventDefault();\n        break;\n      case 'Escape':\n        this.cancel();\n        break;\n      default:\n        break;\n    }\n  }\n\n  private _onBlur(event: FocusEvent) {\n    if (this.isDisposed) {\n      return;\n    }\n\n    if (!this.commit()) {\n      event.preventDefault();\n      event.stopPropagation();\n      this._input.focus();\n    }\n  }\n\n  private _input: HTMLInputElement;\n}\n\n\n/**\n * The namespace for the `CellEditor` class statics.\n */\nexport\nnamespace CellEditor {\n  /**\n   * An object which holds the configuration data for a cell.\n   */\n  export\n  type CellConfig = {\n    /**\n     * The grid containing the cell.\n     */\n    readonly grid: DataGrid;\n    /**\n     * The row index of the cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell.\n     */\n    readonly column: number;\n  };\n}\n\n/**\n * A namespace for module-private functionality.\n */\nnamespace Private {\n  /**\n   * A type alias for cell properties.\n   */\n  export type ICellInfo = {\n    grid: DataGrid,\n    row: number,\n    column: number,\n    data: any,\n    x: number,\n    y: number,\n    width: number,\n    height: number\n  };\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\n\n/**\n * An object which provides the data for a data grid.\n *\n * #### Notes\n * If the predefined data models are insufficient for a particular use\n * case, a custom model can be defined which derives from this class.\n */\nexport\nabstract class DataModel {\n  /**\n   * A signal emitted when the data model has changed.\n   */\n  get changed(): ISignal<this, DataModel.ChangedArgs> {\n    return this._changed;\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract rowCount(region: DataModel.RowRegion): number;\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   *\n   * #### Notes\n   * This method is called often, and so should be efficient.\n   */\n  abstract columnCount(region: DataModel.ColumnRegion): number;\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The data value for the specified cell.\n   *\n   * #### Notes\n   * The returned data should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   */\n  abstract data(region: DataModel.CellRegion, row: number, column: number): any;\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the specified cell.\n   *\n   * #### Notes\n   * The returned metadata should be treated as immutable.\n   *\n   * This method is called often, and so should be efficient.\n   *\n   * The default implementation returns `{}`.\n   */\n  metadata(region: DataModel.CellRegion, row: number, column: number): DataModel.Metadata {\n    return DataModel.emptyMetadata;\n  }\n\n  /**\n   * Emit the `changed` signal for the data model.\n   *\n   * #### Notes\n   * Subclasses should call this method whenever the data model has\n   * changed so that attached data grids can update themselves.\n   */\n  protected emitChanged(args: DataModel.ChangedArgs): void {\n    this._changed.emit(args);\n  }\n\n  private _changed = new Signal<this, DataModel.ChangedArgs>(this);\n}\n\n/**\n * An object which provides the mutable data for a data grid.\n *\n * #### Notes\n * This object is an extension to `DataModel` and it only adds ability to\n * change data for cells.\n */\nexport\nabstract class MutableDataModel extends DataModel {\n  /**\n   * Set the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns true if succeeds, false otherwise.\n   *\n   */\n  abstract setData(region: DataModel.CellRegion, row: number, column: number, value: any): boolean;\n}\n\n\n/**\n * The namespace for the `DataModel` class statics.\n */\nexport\nnamespace DataModel {\n  /**\n   * A type alias for the data model row regions.\n   */\n  export\n  type RowRegion = 'body' | 'column-header';\n\n  /**\n   * A type alias for the data model column regions.\n   */\n  export\n  type ColumnRegion = 'body' | 'row-header';\n\n  /**\n   * A type alias for the data model cell regions.\n   */\n  export\n  type CellRegion = 'body' | 'row-header' | 'column-header' | 'corner-header';\n\n  /**\n   * The metadata for a column in a data model.\n   */\n  export\n  type Metadata = { [key: string]: any };\n\n  /**\n   * A singleton empty metadata object.\n   */\n  export\n  const emptyMetadata: Metadata = Object.freeze({});\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are inserted or removed.\n   */\n  export\n  type RowsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-inserted' | 'rows-removed';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are inserted or removed.\n   */\n  export\n  type ColumnsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-inserted' | 'columns-removed';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when rows are moved.\n   */\n  export\n  type RowsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'rows-moved';\n\n    /**\n     * The region which contains the modified rows.\n     */\n    readonly region: RowRegion;\n\n    /**\n     * The starting index of the first modified row.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified rows.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified row.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when columns are moved.\n   */\n  export\n  type ColumnsMovedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'columns-moved';\n\n    /**\n     * The region which contains the modified columns.\n     */\n    readonly region: ColumnRegion;\n\n    /**\n     * The starting index of the first modified column.\n     */\n    readonly index: number;\n\n    /**\n     * The number of modified columns.\n     */\n    readonly span: number;\n\n    /**\n     * The ending index of the first modified column.\n     */\n    readonly destination: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when cells are changed in-place.\n   */\n  export\n  type CellsChangedArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'cells-changed';\n\n    /**\n     * The region which contains the modified cells.\n     */\n    readonly region: CellRegion;\n\n    /**\n     * The row index of the first modified cell.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the first modified cell.\n     */\n    readonly column: number;\n\n    /**\n     * The number of rows in the modified cell range.\n     */\n    readonly rowSpan: number;\n\n    /**\n     * The number of columns in the modified cell range.\n     */\n    readonly columnSpan: number;\n  };\n\n  /**\n   * An arguments object for the `changed` signal.\n   *\n   * #### Notes\n   * Data models should emit the `changed` signal with this args object\n   * type when the model has changed in a fashion that cannot be easily\n   * expressed by the other args object types.\n   *\n   * This is the \"big hammer\" approach, and will cause any associated\n   * data grid to perform a full reset. The other changed args types\n   * should be used whenever possible.\n   */\n  export\n  type ModelResetArgs = {\n    /**\n     * The discriminated type of the args object.\n     */\n    readonly type: 'model-reset';\n  };\n\n  /**\n   * A type alias for the args objects of the `changed` signal.\n   */\n  export\n  type ChangedArgs = (\n    RowsChangedArgs |\n    ColumnsChangedArgs |\n    RowsMovedArgs |\n    ColumnsMovedArgs |\n    CellsChangedArgs |\n    ModelResetArgs\n  );\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\n\n/**\n * A thin caching wrapper around a 2D canvas rendering context.\n *\n * #### Notes\n * This class is mostly a transparent wrapper around a canvas rendering\n * context which improves performance when writing context state.\n *\n * For best performance, avoid reading state from the `gc`. Writes are\n * cached based on the previously written value.\n *\n * Unless otherwise specified, the API and semantics of this class are\n * identical to the builtin 2D canvas rendering context:\n * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D\n *\n * The wrapped canvas context should not be manipulated externally\n * until the wrapping `GraphicsContext` object is disposed.\n */\nexport\nclass GraphicsContext implements IDisposable {\n  /**\n   * Create a new graphics context object.\n   *\n   * @param context - The 2D canvas rendering context to wrap.\n   */\n  constructor(context: CanvasRenderingContext2D) {\n    this._context = context;\n    this._state = Private.State.create(context);\n  }\n\n  dispose(): void {\n    // Bail if the gc is already disposed.\n    if (this._disposed) {\n      return;\n    }\n\n    // Mark the gc as disposed.\n    this._disposed = true;\n\n    // Pop any unrestored saves.\n    while (this._state.next) {\n      this._state = this._state.next;\n      this._context.restore();\n    }\n  }\n\n  get isDisposed(): boolean {\n    return this._disposed;\n  }\n\n  get fillStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.fillStyle;\n  }\n\n  set fillStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.fillStyle !== value) {\n      this._state.fillStyle = value;\n      this._context.fillStyle = value;\n    }\n  }\n\n  get strokeStyle(): string | CanvasGradient | CanvasPattern {\n    return this._context.strokeStyle;\n  }\n\n  set strokeStyle(value: string | CanvasGradient | CanvasPattern) {\n    if (this._state.strokeStyle !== value) {\n      this._state.strokeStyle = value;\n      this._context.strokeStyle = value;\n    }\n  }\n\n  get font(): string {\n    return this._context.font;\n  }\n\n  set font(value: string) {\n    if (this._state.font !== value) {\n      this._state.font = value;\n      this._context.font = value;\n    }\n  }\n\n  get textAlign(): CanvasTextAlign {\n    return this._context.textAlign;\n  }\n\n  set textAlign(value: CanvasTextAlign) {\n    if (this._state.textAlign !== value) {\n      this._state.textAlign = value;\n      this._context.textAlign = value;\n    }\n  }\n\n  get textBaseline(): CanvasTextBaseline {\n    return this._context.textBaseline;\n  }\n\n  set textBaseline(value: CanvasTextBaseline) {\n    if (this._state.textBaseline !== value) {\n      this._state.textBaseline = value;\n      this._context.textBaseline = value;\n    }\n  }\n\n  get lineCap(): CanvasLineCap {\n    return this._context.lineCap;\n  }\n\n  set lineCap(value: CanvasLineCap) {\n    if (this._state.lineCap !== value) {\n      this._state.lineCap = value;\n      this._context.lineCap = value;\n    }\n  }\n\n  get lineDashOffset(): number {\n    return this._context.lineDashOffset;\n  }\n\n  set lineDashOffset(value: number) {\n    if (this._state.lineDashOffset !== value) {\n      this._state.lineDashOffset = value;\n      this._context.lineDashOffset = value;\n    }\n  }\n\n  get lineJoin(): CanvasLineJoin {\n    return this._context.lineJoin;\n  }\n\n  set lineJoin(value: CanvasLineJoin) {\n    if (this._state.lineJoin !== value) {\n      this._state.lineJoin = value;\n      this._context.lineJoin = value;\n    }\n  }\n\n  get lineWidth(): number {\n    return this._context.lineWidth;\n  }\n\n  set lineWidth(value: number) {\n    if (this._state.lineWidth !== value) {\n      this._state.lineWidth = value;\n      this._context.lineWidth = value;\n    }\n  }\n\n  get miterLimit(): number {\n    return this._context.miterLimit;\n  }\n\n  set miterLimit(value: number) {\n    if (this._state.miterLimit !== value) {\n      this._state.miterLimit = value;\n      this._context.miterLimit = value;\n    }\n  }\n\n  get shadowBlur(): number {\n    return this._context.shadowBlur;\n  }\n\n  set shadowBlur(value: number) {\n    if (this._state.shadowBlur !== value) {\n      this._state.shadowBlur = value;\n      this._context.shadowBlur = value;\n    }\n  }\n\n  get shadowColor(): string {\n    return this._context.shadowColor;\n  }\n\n  set shadowColor(value: string) {\n    if (this._state.shadowColor !== value) {\n      this._state.shadowColor = value;\n      this._context.shadowColor = value;\n    }\n  }\n\n  get shadowOffsetX(): number {\n    return this._context.shadowOffsetX;\n  }\n\n  set shadowOffsetX(value: number) {\n    if (this._state.shadowOffsetX !== value) {\n      this._state.shadowOffsetX = value;\n      this._context.shadowOffsetX = value;\n    }\n  }\n\n  get shadowOffsetY(): number {\n    return this._context.shadowOffsetY;\n  }\n\n  set shadowOffsetY(value: number) {\n    if (this._state.shadowOffsetY !== value) {\n      this._state.shadowOffsetY = value;\n      this._context.shadowOffsetY = value;\n    }\n  }\n\n  get imageSmoothingEnabled(): boolean {\n    return this._context.imageSmoothingEnabled;\n  }\n\n  set imageSmoothingEnabled(value: boolean) {\n    if (this._state.imageSmoothingEnabled !== value) {\n      this._state.imageSmoothingEnabled = value;\n      this._context.imageSmoothingEnabled = value;\n    }\n  }\n\n  get globalAlpha(): number {\n    return this._context.globalAlpha;\n  }\n\n  set globalAlpha(value: number) {\n    if (this._state.globalAlpha !== value) {\n      this._state.globalAlpha = value;\n      this._context.globalAlpha = value;\n    }\n  }\n\n  get globalCompositeOperation(): string {\n    return this._context.globalCompositeOperation;\n  }\n\n  set globalCompositeOperation(value: string) {\n    if (this._state.globalCompositeOperation !== value) {\n      this._state.globalCompositeOperation = value;\n      this._context.globalCompositeOperation = value;\n    }\n  }\n\n  getLineDash(): number[] {\n    return this._context.getLineDash();\n  }\n\n  setLineDash(segments: number[]): void {\n    this._context.setLineDash(segments);\n  }\n\n  rotate(angle: number): void {\n    this._context.rotate(angle);\n  }\n\n  scale(x: number, y: number): void {\n    this._context.scale(x, y);\n  }\n\n  transform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void {\n    this._context.transform(m11, m12, m21, m22, dx, dy);\n  }\n\n  translate(x: number, y: number): void {\n    this._context.translate(x, y);\n  }\n\n  setTransform(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number): void {\n    this._context.setTransform(m11, m12, m21, m22, dx, dy);\n  }\n\n  save(): void {\n    // Clone an push the current state to the stack.\n    this._state = Private.State.push(this._state);\n\n    // Save the wrapped context state.\n    this._context.save();\n  }\n\n  restore(): void {\n    // Bail if there is no state to restore.\n    if (!this._state.next) {\n      return;\n    }\n\n    // Pop the saved state from the stack.\n    this._state = Private.State.pop(this._state);\n\n    // Restore the wrapped context state.\n    this._context.restore();\n  }\n\n  beginPath(): void {\n    return this._context.beginPath();\n  }\n\n  closePath(): void {\n    this._context.closePath();\n  }\n\n  isPointInPath(x: number, y: number, fillRule?: CanvasFillRule): boolean {\n    let result: boolean;\n    if (arguments.length === 2) {\n      result = this._context.isPointInPath(x, y);\n    } else {\n      result = this._context.isPointInPath(x, y, fillRule);\n    }\n    return result;\n  }\n\n  arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void {\n    if (arguments.length === 5) {\n      this._context.arc(x, y, radius, startAngle, endAngle);\n    } else {\n      this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);\n    }\n  }\n\n  arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void {\n    this._context.arcTo(x1, y1, x2, y2, radius);\n  }\n\n  bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void {\n    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n\n  ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise?: boolean): void {\n    if (arguments.length === 7) {\n      this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);\n    } else {\n      this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);\n    }\n  }\n\n  lineTo(x: number, y: number): void {\n    this._context.lineTo(x, y);\n  }\n\n  moveTo(x: number, y: number): void {\n    this._context.moveTo(x, y);\n  }\n\n  quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void {\n    this._context.quadraticCurveTo(cpx, cpy, x, y);\n  }\n\n  rect(x: number, y: number, w: number, h: number): void {\n    this._context.rect(x, y, w, h);\n  }\n\n  clip(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.clip();\n    } else {\n      this._context.clip(fillRule);\n    }\n  }\n\n  fill(fillRule?: CanvasFillRule): void {\n    if (arguments.length === 0) {\n      this._context.fill();\n    } else {\n      this._context.fill(fillRule);\n    }\n  }\n\n  stroke(): void {\n    this._context.stroke();\n  }\n\n  clearRect(x: number, y: number, w: number, h: number): void {\n    return this._context.clearRect(x, y, w, h);\n  }\n\n  fillRect(x: number, y: number, w: number, h: number): void {\n    this._context.fillRect(x, y, w, h);\n  }\n\n  fillText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.fillText(text, x, y);\n    } else {\n      this._context.fillText(text, x, y, maxWidth);\n    }\n  }\n\n  strokeRect(x: number, y: number, w: number, h: number): void {\n    this._context.strokeRect(x, y, w, h);\n  }\n\n  strokeText(text: string, x: number, y: number, maxWidth?: number): void {\n    if (arguments.length === 3) {\n      this._context.strokeText(text, x, y);\n    } else {\n      this._context.strokeText(text, x, y, maxWidth);\n    }\n  }\n\n  measureText(text: string): TextMetrics {\n    return this._context.measureText(text);\n  }\n\n  createLinearGradient(x0: number, y0: number, x1: number, y1: number): CanvasGradient {\n    return this._context.createLinearGradient(x0, y0, x1, y1);\n  }\n\n  createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): CanvasGradient {\n    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n\n  createPattern(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement, repetition: string): CanvasPattern | null {\n    return this._context.createPattern(image, repetition);\n  }\n\n  createImageData(imageData: ImageData): ImageData;\n  createImageData(sw: number, sh: number): ImageData;\n  createImageData() {\n    return this._context.createImageData.apply(this._context, arguments);\n  }\n\n  getImageData(sx: number, sy: number, sw: number, sh: number): ImageData {\n    return this._context.getImageData(sx, sy, sw, sh);\n  }\n\n  putImageData(imagedata: ImageData, dx: number, dy: number): void\n  putImageData(imagedata: ImageData, dx: number, dy: number, dirtyX: number, dirtyY: number, dirtyWidth: number, dirtyHeight: number): void\n  putImageData(): void {\n    this._context.putImageData.apply(this._context, arguments);\n  }\n\n  drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number): void;\n  drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, dstX: number, dstY: number, dstW: number, dstH: number): void;\n  drawImage(image: HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap, srcX: number, srcY: number, srcW: number, srcH: number, dstX: number, dstY: number, dstW: number, dstH: number): void;\n  drawImage(): void {\n    this._context.drawImage.apply(this._context, arguments);\n  }\n\n  drawFocusIfNeeded(element: Element): void {\n    this._context.drawFocusIfNeeded(element);\n  }\n\n  private _disposed = false;\n  private _state: Private.State;\n  private _context: CanvasRenderingContext2D;\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * The index of next valid pool object.\n   */\n  let pi = -1;\n\n  /**\n   * A state object allocation pool.\n   */\n  const pool: State[] = [];\n\n  /**\n   * An object which holds the state for a gc.\n   */\n  export\n  class State {\n    /**\n     * Create a gc state object from a 2D canvas context.\n     */\n    static create(context: CanvasRenderingContext2D): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = null;\n      state.fillStyle = context.fillStyle;\n      state.font = context.font;\n      state.globalAlpha = context.globalAlpha;\n      state.globalCompositeOperation = context.globalCompositeOperation;\n      state.imageSmoothingEnabled = context.imageSmoothingEnabled;\n      state.lineCap = context.lineCap;\n      state.lineDashOffset = context.lineDashOffset;\n      state.lineJoin = context.lineJoin;\n      state.lineWidth = context.lineWidth;\n      state.miterLimit = context.miterLimit;\n      state.shadowBlur = context.shadowBlur;\n      state.shadowColor = context.shadowColor;\n      state.shadowOffsetX = context.shadowOffsetX;\n      state.shadowOffsetY = context.shadowOffsetY;\n      state.strokeStyle = context.strokeStyle;\n      state.textAlign = context.textAlign;\n      state.textBaseline = context.textBaseline;\n      return state;\n    }\n\n    /**\n     * Clone an existing gc state object and add it to the state stack.\n     */\n    static push(other: State): State {\n      let state = pi < 0 ? new State() : pool[pi--];\n      state.next = other;\n      state.fillStyle = other.fillStyle;\n      state.font = other.font;\n      state.globalAlpha = other.globalAlpha;\n      state.globalCompositeOperation = other.globalCompositeOperation;\n      state.imageSmoothingEnabled = other.imageSmoothingEnabled;\n      state.lineCap = other.lineCap;\n      state.lineDashOffset = other.lineDashOffset;\n      state.lineJoin = other.lineJoin;\n      state.lineWidth = other.lineWidth;\n      state.miterLimit = other.miterLimit;\n      state.shadowBlur = other.shadowBlur;\n      state.shadowColor = other.shadowColor;\n      state.shadowOffsetX = other.shadowOffsetX;\n      state.shadowOffsetY = other.shadowOffsetY;\n      state.strokeStyle = other.strokeStyle;\n      state.textAlign = other.textAlign;\n      state.textBaseline = other.textBaseline;\n      return state;\n    }\n\n    /**\n     * Pop the next state object and return the current to the pool\n     */\n    static pop(state: State): State {\n      state.fillStyle = '';\n      state.strokeStyle = '';\n      pool[++pi] = state;\n      return state.next!;\n    }\n\n    next: State | null;\n\n    fillStyle: string | CanvasGradient | CanvasPattern;\n    font: string;\n    globalAlpha: number;\n    globalCompositeOperation: string;\n    imageSmoothingEnabled: boolean;\n    lineCap: string;\n    lineDashOffset: number;\n    lineJoin: string;\n    lineWidth: number;\n    miterLimit: number;\n    shadowBlur: number;\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n    strokeStyle: string | CanvasGradient | CanvasPattern;\n    textAlign: string;\n    textBaseline: string;\n\n    private constructor() { }\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  CellRenderer\n} from './cellrenderer';\n\nimport {\n  GraphicsContext\n} from './graphicscontext';\n\n\n/**\n * A cell renderer which renders data values as text.\n */\nexport\nclass TextRenderer extends CellRenderer {\n  /**\n   * Construct a new text renderer.\n   *\n   * @param options - The options for initializing the renderer.\n   */\n  constructor(options: TextRenderer.IOptions = {}) {\n    super();\n    this.font = options.font || '12px sans-serif';\n    this.textColor = options.textColor || '#000000';\n    this.backgroundColor = options.backgroundColor || '';\n    this.verticalAlignment = options.verticalAlignment || 'center';\n    this.horizontalAlignment = options.horizontalAlignment || 'left';\n    this.format = options.format || TextRenderer.formatGeneric();\n    this.elideDirection = options.elideDirection || 'right';\n    this.wrapText = options.wrapText || false;\n  }\n\n  /**\n   * The CSS shorthand font for drawing the text.\n   */\n  readonly font: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for drawing the text.\n   */\n  readonly textColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The CSS color for the cell background.\n   */\n  readonly backgroundColor: CellRenderer.ConfigOption<string>;\n\n  /**\n   * The vertical alignment for the cell text.\n   */\n  readonly verticalAlignment: CellRenderer.ConfigOption<TextRenderer.VerticalAlignment>;\n\n  /**\n   * The horizontal alignment for the cell text.\n   */\n  readonly horizontalAlignment: CellRenderer.ConfigOption<TextRenderer.HorizontalAlignment>;\n\n  /**\n   * The format function for the cell value.\n   */\n  readonly format: TextRenderer.FormatFunc;\n\n  /**\n   * Which side to draw the ellipsis.\n   */\n  readonly elideDirection: CellRenderer.ConfigOption<TextRenderer.ElideDirection>;\n\n  /**\n   * Boolean flag for applying text wrapping.\n   */\n  readonly wrapText: CellRenderer.ConfigOption<boolean>;\n\n  /**\n   * Paint the content for a cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  paint(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    this.drawBackground(gc, config);\n    this.drawText(gc, config);\n  }\n\n  /**\n   * Draw the background for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawBackground(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the background color for the cell.\n    let color = CellRenderer.resolveOption(this.backgroundColor, config);\n\n    // Bail if there is no background color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Fill the cell with the background color.\n    gc.fillStyle = color;\n    gc.fillRect(config.x, config.y, config.width, config.height);\n  }\n\n  /**\n   * Draw the text for the cell.\n   *\n   * @param gc - The graphics context to use for drawing.\n   *\n   * @param config - The configuration data for the cell.\n   */\n  drawText(gc: GraphicsContext, config: CellRenderer.CellConfig): void {\n    // Resolve the font for the cell.\n    let font = CellRenderer.resolveOption(this.font, config);\n\n    // Bail if there is no font to draw.\n    if (!font) {\n      return;\n    }\n\n    // Resolve the text color for the cell.\n    let color = CellRenderer.resolveOption(this.textColor, config);\n\n    // Bail if there is no text color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Format the cell value to text.\n    let format = this.format;\n    let text = format(config);\n\n    // Bail if there is no text to draw.\n    if (!text) {\n      return;\n    }\n\n    // Resolve the vertical and horizontal alignment.\n    let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);\n    let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);\n\n    // Resolve the elision direction\n    let elideDirection = CellRenderer.resolveOption(this.elideDirection, config);\n\n    // Resolve the text wrapping flag\n    let wrapText = CellRenderer.resolveOption(this.wrapText, config);\n\n    // Compute the padded text box height for the specified alignment.\n    let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);\n\n    // Bail if the text box has no effective size.\n    if (boxHeight <= 0) {\n      return;\n    }\n\n    // Compute the text height for the gc font.\n    let textHeight = TextRenderer.measureFontHeight(font);\n\n    // Set up the text position variables.\n    let textX: number;\n    let textY: number;\n    let boxWidth: number;\n\n    // Compute the Y position for the text.\n    switch (vAlign) {\n    case 'top':\n      textY = config.y + 2 + textHeight;\n      break;\n    case 'center':\n      textY = config.y + config.height / 2 + textHeight / 2;\n      break;\n    case 'bottom':\n      textY = config.y + config.height - 2;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Compute the X position for the text.\n    switch (hAlign) {\n    case 'left':\n      textX = config.x + 8;\n      boxWidth = config.width - 14;\n      break;\n    case 'center':\n      textX = config.x + config.width / 2;\n      boxWidth = config.width;\n      break;\n    case 'right':\n      textX = config.x + config.width - 8;\n      boxWidth = config.width - 14;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Clip the cell if the text is taller than the text box height.\n    if (textHeight > boxHeight) {\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n    }\n\n    // Set the gc state.\n    gc.font = font;\n    gc.fillStyle = color;\n    gc.textAlign = hAlign;\n    gc.textBaseline = 'bottom';\n\n    // The current text width in pixels.\n    let textWidth = gc.measureText(text).width;\n\n    // Apply text wrapping if enabled.\n    if (wrapText && textWidth > boxWidth) {\n      // Make sure box clipping happens.\n      gc.beginPath();\n      gc.rect(config.x, config.y, config.width, config.height - 1);\n      gc.clip();\n\n      // Split column name to words based on\n      // whitespace preceding a word boundary.\n      // \"Hello  world\" --> [\"Hello  \", \"world\"]\n      const wordsInColumn = text.split(/\\s(?=\\b)/);\n\n      // Y-coordinate offset for any additional lines\n      let curY = textY;\n      let textInCurrentLine = wordsInColumn.shift()!\n\n      // Single word. Applying text wrap on word by splitting\n      // it into characters and fitting the maximum number of\n      // characters possible per line (box width).\n      if (wordsInColumn.length === 0) {\n        let curLineTextWidth = gc.measureText(textInCurrentLine).width;\n        while (curLineTextWidth > boxWidth && textInCurrentLine !== \"\") {\n          // Iterating from the end of the string until we find a\n          // substring (0,i) which has a width less than the box width.\n          for (let i = textInCurrentLine.length; i > 0; i--) {\n            const curSubString = textInCurrentLine.substring(0,i);\n            const curSubStringWidth = gc.measureText(curSubString).width;\n            if (curSubStringWidth < boxWidth || curSubString.length === 1) {\n              // Found a substring which has a width less than the current\n              // box width. Rendering that substring on the current line\n              // and setting the remainder of the parent string as the next\n              // string to iterate on for the next line.\n              const nextLineText = textInCurrentLine.substring(i, textInCurrentLine.length);\n              textInCurrentLine = nextLineText;\n              curLineTextWidth = gc.measureText(textInCurrentLine).width;\n              gc.fillText(curSubString, textX, curY);\n              curY += textHeight;\n              // No need to continue iterating after we identified\n              // an index to break the string on.\n              break;\n            }\n          }\n        }\n      }\n      \n      // Multiple words in column header. Fitting maximum \n      // number of words possible per line (box width).\n      else {\n        while (wordsInColumn.length !== 0) {\n          // Processing the next word in the queue.\n          const curWord = wordsInColumn.shift();\n          // Joining that word with the existing text for\n          // the current line.\n          const incrementedText = [textInCurrentLine, curWord].join(\" \");\n          const incrementedTextWidth = gc.measureText(incrementedText).width;\n          if (incrementedTextWidth > boxWidth) {\n            // If the newly combined text has a width larger than\n            // the box width, we render the line before the current\n            // word was added. We set the current word as the next\n            // line.\n            gc.fillText(textInCurrentLine, textX, curY);\n            curY += textHeight;\n            textInCurrentLine = curWord!;\n          } \n          else {\n            // The combined text hasd a width less than the box width. We\n            // set the the current line text to be the new combined text.\n            textInCurrentLine = incrementedText;\n          }\n        }\n      }\n      gc.fillText(textInCurrentLine!, textX, curY);\n      // Terminating the call here as we don't want\n      // to apply text eliding when wrapping is active.\n      return;\n    }\n\n    // Elide text that is too long\n    let elide = '\\u2026';\n\n    // Compute elided text\n    if (elideDirection === 'right') {\n      while ((textWidth > boxWidth) && (text.length > 1)) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = text.substring(0, (text.length / 2) + 1) + elide;\n        } else {\n          // Otherwise incrementally remove the last character\n          text = text.substring(0, text.length - 2) + elide;\n        }\n        textWidth = gc.measureText(text).width;\n      } \n    } else {\n      while ((textWidth > boxWidth) && (text.length > 1)) {\n        if (text.length > 4 && textWidth >= 2 * boxWidth) {\n          // If text width is substantially bigger, take half the string\n          text = elide + text.substring((text.length / 2));\n        } else {\n          // Otherwise incrementally remove the last character\n          text = elide + text.substring(2);\n        }\n        textWidth = gc.measureText(text).width;\n      }\n    }\n\n    // Draw the text for the cell.\n    gc.fillText(text, textX, textY);\n  }\n}\n\n\n/**\n * The namespace for the `TextRenderer` class statics.\n */\nexport\nnamespace TextRenderer {\n  /**\n   * A type alias for the supported vertical alignment modes.\n   */\n  export\n  type VerticalAlignment = 'top' | 'center' | 'bottom';\n\n  /**\n   * A type alias for the supported horizontal alignment modes.\n   */\n  export\n  type HorizontalAlignment = 'left' | 'center' | 'right';\n\n  /**\n   * A type alias for the supported ellipsis sides.\n   */\n  export\n  type ElideDirection = 'left' | 'right';\n\n  /**\n   * An options object for initializing a text renderer.\n   */\n  export\n  interface IOptions {\n    /**\n     * The font for drawing the cell text.\n     *\n     * The default is `'12px sans-serif'`.\n     */\n    font?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The color for the drawing the cell text.\n     *\n     * The default `'#000000'`.\n     */\n    textColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The background color for the cells.\n     *\n     * The default is `''`.\n     */\n    backgroundColor?: CellRenderer.ConfigOption<string>;\n\n    /**\n     * The vertical alignment for the cell text.\n     *\n     * The default is `'center'`.\n     */\n    verticalAlignment?: CellRenderer.ConfigOption<VerticalAlignment>;\n\n    /**\n     * The horizontal alignment for the cell text.\n     *\n     * The default is `'left'`.\n     */\n    horizontalAlignment?: CellRenderer.ConfigOption<HorizontalAlignment>;\n\n    /**\n     * The format function for the renderer.\n     *\n     * The default is `TextRenderer.formatGeneric()`.\n     */\n    format?: FormatFunc;\n\n    /**\n     * The ellipsis direction for the cell text.\n     *\n     * The default is `'right'`.\n     */\n    elideDirection?: CellRenderer.ConfigOption<ElideDirection>;\n\n    /**\n     * Whether or not to apply text wrapping.\n     *\n     * The default is `'false'`.\n     */\n    wrapText?: CellRenderer.ConfigOption<boolean>;\n  }\n\n  /**\n   * A type alias for a format function.\n   */\n  export\n  type FormatFunc = CellRenderer.ConfigFunc<string>;\n\n  /**\n   * Create a generic text format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new generic text format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `String()` to coerce any value\n   * to a string.\n   */\n  export\n  function formatGeneric(options: formatGeneric.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return String(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatGeneric` function statics.\n   */\n  export\n  namespace formatGeneric {\n    /**\n     * The options for creating a generic format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a fixed decimal format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new fixed decimal format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toFixed()` to\n   * coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export\n  function formatFixed(options: formatFixed.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toFixed(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatFixed` function statics.\n   */\n  export\n  namespace formatFixed {\n    /**\n     * The options for creating a fixed format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a significant figure format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new significant figure format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toPrecision()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export\n  function formatPrecision(options: formatPrecision.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toPrecision(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatPrecision` function statics.\n   */\n  export\n  namespace formatPrecision {\n    /**\n     * The options for creating a precision format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The number of significant figures to include in the value.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a scientific notation format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new scientific notation format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Number()` and `toExponential()`\n   * to coerce values.\n   *\n   * The `formatIntlNumber()` formatter is more flexible, but slower.\n   */\n  export\n  function formatExponential(options: formatExponential.IOptions = {}): FormatFunc {\n    let digits = options.digits;\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return Number(value).toExponential(digits);\n    };\n  }\n\n  /**\n   * The namespace for the `formatExponential` function statics.\n   */\n  export\n  namespace formatExponential {\n    /**\n     * The options for creating an exponential format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The number of digits to include after the decimal point.\n       *\n       * The default is determined by the user agent.\n       */\n      digits?: number;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international number format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international number format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.NumberFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) number formatter.\n   */\n  export\n  function formatIntlNumber(options: formatIntlNumber.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    let nft = new Intl.NumberFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return nft.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlNumber` function statics.\n   */\n  export\n  namespace formatIntlNumber {\n    /**\n     * The options for creating an intl number format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The locales to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.NumberFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.NumberFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a date format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new date format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toDateString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatDate(options: formatDate.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toDateString();\n      }\n      return (new Date(value)).toDateString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatDate` function statics.\n   */\n  export\n  namespace formatDate {\n    /**\n     * The options for creating a date format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a time format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new time format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toTimeString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatTime(options: formatTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toTimeString();\n      }\n      return (new Date(value)).toTimeString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatTime` function statics.\n   */\n  export\n  namespace formatTime {\n    /**\n     * The options for creating a time format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an ISO datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new ISO datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toISOString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatISODateTime(options: formatISODateTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toISOString();\n      }\n      return (new Date(value)).toISOString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatISODateTime` function statics.\n   */\n  export\n  namespace formatISODateTime {\n    /**\n     * The options for creating an ISO datetime format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create a UTC datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new UTC datetime format function.\n   *\n   * #### Notes\n   * This formatter uses `Date.toUTCString()` to format the values.\n   *\n   * If a value is not a `Date` object, `new Date(value)` is used to\n   * coerce the value to a date.\n   *\n   * The `formatIntlDateTime()` formatter is more flexible, but slower.\n   */\n  export\n  function formatUTCDateTime(options: formatUTCDateTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      if (value instanceof Date) {\n        return value.toUTCString();\n      }\n      return (new Date(value)).toUTCString();\n    };\n  }\n\n  /**\n   * The namespace for the `formatUTCDateTime` function statics.\n   */\n  export\n  namespace formatUTCDateTime {\n    /**\n     * The options for creating a UTC datetime format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Create an international datetime format function.\n   *\n   * @param options - The options for creating the format function.\n   *\n   * @returns A new international datetime format function.\n   *\n   * #### Notes\n   * This formatter uses the builtin `Intl.DateTimeFormat` object to\n   * coerce values.\n   *\n   * This is the most flexible (but slowest) datetime formatter.\n   */\n  export\n  function formatIntlDateTime(options: formatIntlDateTime.IOptions = {}): FormatFunc {\n    let missing = options.missing || '';\n    let dtf = new Intl.DateTimeFormat(options.locales, options.options);\n    return ({ value }) => {\n      if (value === null || value === undefined) {\n        return missing;\n      }\n      return dtf.format(value);\n    };\n  }\n\n  /**\n   * The namespace for the `formatIntlDateTime` function statics.\n   */\n  export\n  namespace formatIntlDateTime {\n    /**\n     * The options for creating an intl datetime format function.\n     */\n    export\n    interface IOptions {\n      /**\n       * The locales to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      locales?: string | string[];\n\n      /**\n       * The options to pass to the `Intl.DateTimeFormat` constructor.\n       *\n       * The default is determined by the user agent.\n       */\n      options?: Intl.DateTimeFormatOptions;\n\n      /**\n       * The text to use for a `null` or `undefined` data value.\n       *\n       * The default is `''`.\n       */\n      missing?: string;\n    }\n  }\n\n  /**\n   * Measure the height of a font.\n   *\n   * @param font - The CSS font string of interest.\n   *\n   * @returns The height of the font bounding box.\n   *\n   * #### Notes\n   * This function uses a temporary DOM node to measure the text box\n   * height for the specified font. The first call for a given font\n   * will incur a DOM reflow, but the return value is cached, so any\n   * subsequent call for the same font will return the cached value.\n   */\n  export\n  function measureFontHeight(font: string): number {\n    // Look up the cached font height.\n    let height = Private.fontHeightCache[font];\n\n    // Return the cached font height if it exists.\n    if (height !== undefined) {\n      return height;\n    }\n\n    // Normalize the font.\n    Private.fontMeasurementGC.font = font;\n    let normFont = Private.fontMeasurementGC.font;\n\n    // Set the font on the measurement node.\n    Private.fontMeasurementNode.style.font = normFont;\n\n    // Add the measurement node to the document.\n    document.body.appendChild(Private.fontMeasurementNode);\n\n    // Measure the node height.\n    height = Private.fontMeasurementNode.offsetHeight;\n\n    // Remove the measurement node from the document.\n    document.body.removeChild(Private.fontMeasurementNode);\n\n    // Cache the measured height for the font and norm font.\n    Private.fontHeightCache[font] = height;\n    Private.fontHeightCache[normFont] = height;\n\n    // Return the measured height.\n    return height;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A cache of measured font heights.\n   */\n  export\n  const fontHeightCache: { [font: string]: number } = Object.create(null);\n\n  /**\n   * The DOM node used for font height measurement.\n   */\n  export\n  const fontMeasurementNode = (() => {\n    let node = document.createElement('div');\n    node.style.position = 'absolute';\n    node.style.top = '-99999px';\n    node.style.left = '-99999px';\n    node.style.visibility = 'hidden';\n    node.textContent = 'M';\n    return node;\n  })();\n\n  /**\n   * The GC used for font measurement.\n   */\n  export\n  const fontMeasurementGC = (() => {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas.getContext('2d')!;\n  })();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ArrayExt\n} from '@lumino/algorithm';\n\n\n/**\n * An object which manages a collection of variable sized sections.\n *\n * #### Notes\n * This class is an implementation detail. It is designed to manage\n * the variable row and column sizes for a data grid. User code will\n * not interact with this class directly.\n */\nexport\nclass SectionList {\n  /**\n   * Construct a new section list.\n   *\n   * @param options - The options for initializing the list.\n   */\n  constructor(options: SectionList.IOptions) {\n    this._minimumSize = options.minimumSize || 2;\n    this._defaultSize = Math.max(this._minimumSize, Math.floor(options.defaultSize));\n  }\n\n  /**\n   * The total size of all sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get length(): number {\n    return this._length;\n  }\n\n  /**\n   * The total number of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get count(): number {\n    return this._count;\n  }\n\n  /**\n   * Get the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get minimumSize(): number {\n    return this._minimumSize;\n  }\n\n  /**\n   * Set the minimum size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set minimumSize(value: number) {\n    // Normalize the value.\n    value = Math.max(2, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._minimumSize === value) {\n      return;\n    }\n\n    // Update the internal minimum size.\n    this._minimumSize = value;\n\n    // Update default size if larger than minimum size\n    if (value > this._defaultSize) {\n      this.defaultSize = value;\n    }\n  }\n\n  /**\n   * Get the default size of sections in the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  get defaultSize(): number {\n    return this._defaultSize;\n  }\n\n  /**\n   * Set the default size of sections in the list.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  set defaultSize(value: number) {\n    // Normalize the value.\n    value = Math.max(this._minimumSize, Math.floor(value));\n\n    // Bail early if the value does not change.\n    if (this._defaultSize === value) {\n      return;\n    }\n\n    // Compute the delta default size.\n    let delta = value - this._defaultSize;\n\n    // Update the internal default size.\n    this._defaultSize = value;\n\n    // Update the length.\n    this._length += delta * (this._count - this._sections.length);\n\n    // Bail early if there are no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Recompute the offsets of the modified sections.\n    for (let i = 0, n = this._sections.length; i < n; ++i) {\n      // Look up the previous and current modified sections.\n      let prev = this._sections[i - 1];\n      let curr = this._sections[i];\n\n      // Adjust the offset for the current section.\n      if (prev) {\n        let count = curr.index - prev.index - 1;\n        curr.offset = prev.offset + prev.size + count * value;\n      } else {\n        curr.offset = curr.index * value;\n      }\n    }\n  }\n\n  /**\n   * Clamp a size to the minimum section size\n   *\n   * @param size - The size to clamp.\n   *\n   * @returns The size or the section minimum size, whichever is larger\n   */\n  clampSize(size: number): number {\n    return Math.max(this._minimumSize, Math.floor(size));\n  }\n\n  /**\n   * Find the index of the section which covers the given offset.\n   *\n   * @param offset - The offset of the section of interest.\n   *\n   * @returns The index of the section which covers the given offset,\n   *   or `-1` if the offset is out of range.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  indexOf(offset: number): number {\n    // Bail early if the offset is out of range.\n    if (offset < 0 || offset >= this._length || this._count === 0) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Find the modified section for the given offset.\n    let i = ArrayExt.lowerBound(this._sections, offset, Private.offsetCmp);\n\n    // Return the index of an exact match.\n    if (i < this._sections.length && this._sections[i].offset <= offset) {\n      return this._sections[i].index;\n    }\n\n    // Handle the case of no modified sections before the offset.\n    if (i === 0) {\n      return Math.floor(offset / this._defaultSize);\n    }\n\n    // Compute the index from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = offset - (section.offset + section.size);\n    return section.index + Math.floor(span / this._defaultSize) + 1;\n  }\n\n  /**\n   * Find the offset of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The offset of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  offsetOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return index * this._defaultSize;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index - 1;\n    return section.offset + section.size + span * this._defaultSize;\n  }\n\n  /**\n   * Find the extent of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The extent of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  extentOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the offset of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].offset + this._sections[i].size - 1;\n    }\n\n    // Handle the case of no modified sections before the index.\n    if (i === 0) {\n      return (index + 1) * this._defaultSize - 1;\n    }\n\n    // Compute the offset from the previous modified section.\n    let section = this._sections[i - 1];\n    let span = index - section.index;\n    return section.offset + section.size + span * this._defaultSize - 1;\n  }\n\n  /**\n   * Find the size of the section at the given index.\n   *\n   * @param index - The index of the section of interest.\n   *\n   * @returns The size of the section at the given index, or `-1`\n   *   if the index is out of range.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Logarithmic on the number of resized sections.\n   */\n  sizeOf(index: number): number {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return -1;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return this._defaultSize;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Return the size of an exact match.\n    if (i < this._sections.length && this._sections[i].index === index) {\n      return this._sections[i].size;\n    }\n\n    // Return the default size for all other cases.\n    return this._defaultSize;\n  }\n\n  /**\n   * Resize a section in the list.\n   *\n   * @param index - The index of the section to resize. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param size - The new size of the section. This value will be\n   *   clamped to an integer `>= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  resize(index: number, size: number): void {\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= this._count) {\n      return;\n    }\n\n    // Clamp the size to an integer >= minimum size.\n    size = Math.max(this._minimumSize, Math.floor(size));\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update or create the modified section as needed.\n    let delta: number;\n    if (i < this._sections.length && this._sections[i].index === index) {\n      let section = this._sections[i];\n      delta = size - section.size;\n      section.size = size;\n    } else if (i === 0) {\n      let offset = index * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    } else {\n      let section = this._sections[i - 1];\n      let span = index - section.index - 1;\n      let offset = section.offset + section.size + span * this._defaultSize;\n      ArrayExt.insert(this._sections, i, { index, offset, size });\n      delta = size - this._defaultSize;\n    }\n\n    // Adjust the length.\n    this._length += delta;\n\n    // Update all modified sections after the resized section.\n    for (let j = i + 1, n = this._sections.length; j < n; ++j) {\n      this._sections[j].offset += delta;\n    }\n  }\n\n  /**\n   * Insert sections into the list.\n   *\n   * @param index - The index at which to insert the sections. This\n   *   value will be clamped to the bounds of the list.\n   *\n   * @param count - The number of sections to insert. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  insert(index: number, count: number): void {\n    // Bail early if there are no sections to insert.\n    if (count <= 0) {\n      return;\n    }\n\n    // Clamp the index to the bounds of the list.\n    index = Math.max(0, Math.min(index, this._count));\n\n    // Add the new sections to the totals.\n    let span = count * this._defaultSize;\n    this._count += count;\n    this._length += span;\n\n    // Bail early if there are no modified sections to update.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Find the modified section for the given index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Update all modified sections after the insert location.\n    for (let n = this._sections.length; i < n; ++i) {\n      let section = this._sections[i];\n      section.index += count;\n      section.offset += span;\n    }\n  }\n\n  /**\n   * Remove sections from the list.\n   *\n   * @param index - The index of the first section to remove. This\n   *   method is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to remove. This method\n   *   is a no-op if this value is `<= 0`.\n   *\n   * #### Undefined Behavior\n   * An `index` or `count` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of resized sections.\n   */\n  remove(index: number, count: number): void {\n    // Bail early if there is nothing to remove.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Clamp the count to the bounds of the list.\n    count = Math.min(this._count - index, count);\n\n    // Handle the simple case of no modified sections to update.\n    if (this._sections.length === 0) {\n      this._count -= count;\n      this._length -= count * this._defaultSize;\n      return;\n    }\n\n    // Handle the simple case of removing all sections.\n    if (count === this._count) {\n      this._length = 0;\n      this._count = 0;\n      this._sections.length = 0;\n      return;\n    }\n\n    // Find the modified section for the start index.\n    let i = ArrayExt.lowerBound(this._sections, index, Private.indexCmp);\n\n    // Find the modified section for the end index.\n    let j = ArrayExt.lowerBound(this._sections, index + count, Private.indexCmp);\n\n    // Remove the relevant modified sections.\n    let removed = this._sections.splice(i, j - i);\n\n    // Compute the total removed span.\n    let span = (count - removed.length) * this._defaultSize;\n    for (let k = 0, n = removed.length; k < n; ++k) {\n      span += removed[k].size;\n    }\n\n    // Adjust the totals.\n    this._count -= count;\n    this._length -= span;\n\n    // Update all modified sections after the removed span.\n    for (let k = i, n = this._sections.length; k < n; ++k) {\n      let section = this._sections[k];\n      section.index -= count;\n      section.offset -= span;\n    }\n  }\n\n  /**\n   * Move sections within the list.\n   *\n   * @param index - The index of the first section to move. This method\n   *   is a no-op if this value is out of range.\n   *\n   * @param count - The number of sections to move. This method is a\n   *   no-op if this value is `<= 0`.\n   *\n   * @param destination - The destination index for the first section.\n   *   This value will be clamped to the allowable range.\n   *\n   * #### Undefined Behavior\n   * An `index`, `count`, or `destination` which is non-integral.\n   *\n   * #### Complexity\n   * Linear on the number of moved resized sections.\n   */\n  move(index: number, count: number, destination: number): void {\n    // Bail early if there is nothing to move.\n    if (index < 0 || index >= this._count || count <= 0) {\n      return;\n    }\n\n    // Handle the simple case of no modified sections.\n    if (this._sections.length === 0) {\n      return;\n    }\n\n    // Clamp the move count to the limit.\n    count = Math.min(count, this._count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), this._count - count);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let i1 = Math.min(index, destination);\n\n    // Look up the first affected modified section.\n    let k1 = ArrayExt.lowerBound(this._sections, i1, Private.indexCmp);\n\n    // Bail early if there are no affected modified sections.\n    if (k1 === this._sections.length) {\n      return;\n    }\n\n    // Compute the last affected index.\n    let i2 = Math.max(index + count - 1, destination + count - 1);\n\n    // Look up the last affected modified section.\n    let k2 = ArrayExt.upperBound(this._sections, i2, Private.indexCmp) - 1;\n\n    // Bail early if there are no affected modified sections.\n    if (k2 < k1) {\n      return;\n    }\n\n    // Compute the pivot index.\n    let pivot = destination < index ? index : index + count;\n\n    // Compute the count for each side of the pivot.\n    let count1 = pivot - i1;\n    let count2 = i2 - pivot + 1;\n\n    // Compute the span for each side of the pivot.\n    let span1 = count1 * this._defaultSize;\n    let span2 = count2 * this._defaultSize;\n\n    // Adjust the spans for the modified sections.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        span1 += section.size - this._defaultSize;\n      } else {\n        span2 += section.size - this._defaultSize;\n      }\n    }\n\n    // Look up the pivot section.\n    let k3 = ArrayExt.lowerBound(this._sections, pivot, Private.indexCmp);\n\n    // Rotate the modified sections if needed.\n    if (k1 <= k3 && k3 <= k2) {\n      ArrayExt.rotate(this._sections, k3 - k1, k1, k2);\n    }\n\n    // Adjust the modified section indices and offsets.\n    for (let j = k1; j <= k2; ++j) {\n      let section = this._sections[j];\n      if (section.index < pivot) {\n        section.index += count2;\n        section.offset += span2;\n      } else {\n        section.index -= count1;\n        section.offset -= span1;\n      }\n    }\n  }\n\n  /**\n   * Reset all modified sections to the default size.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  reset(): void {\n    this._sections.length = 0;\n    this._length = this._count * this._defaultSize;\n  }\n\n  /**\n   * Remove all sections from the list.\n   *\n   * #### Complexity\n   * Constant.\n   */\n  clear(): void {\n    this._count = 0;\n    this._length = 0;\n    this._sections.length = 0;\n  }\n\n  private _count = 0;\n  private _length = 0;\n  private _minimumSize: number;\n  private _defaultSize: number;\n  private _sections: Private.Section[] = [];\n}\n\n\n/**\n * The namespace for the `SectionList` class statics.\n */\nexport\nnamespace SectionList {\n  /**\n   * An options object for initializing a section list.\n   */\n  export\n  interface IOptions {\n    /**\n     * The size of new sections added to the list.\n     */\n    defaultSize: number;\n\n    /**\n     * The minimum size of the section list.\n     */\n    minimumSize?: number;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which represents a modified section.\n   */\n  export\n  type Section = {\n    /**\n     * The index of the section.\n     *\n     * This is always `>= 0`.\n     */\n    index: number;\n\n    /**\n     * The offset of the section.\n     */\n    offset: number;\n\n    /**\n     * The size of the section.\n     *\n     * This is always `>= 0`.\n     */\n    size: number;\n  };\n\n  /**\n   * A comparison function for searching by offset.\n   */\n  export\n  function offsetCmp(section: Section, offset: number): number {\n    if (offset < section.offset) {\n      return 1;\n    }\n    if (section.offset + section.size <= offset) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * A comparison function for searching by index.\n   */\n  export\n  function indexCmp(section: Section, index: number): number {\n    return section.index - index;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ISignal, Signal\n} from '@lumino/signaling';\n\nimport {\n  CellRenderer\n} from './cellrenderer';\n\nimport {\n  DataModel\n} from './datamodel';\n\nimport {\n  TextRenderer\n} from './textrenderer';\n\n\n/**\n * A class which manages the mapping of cell renderers.\n */\nexport\nclass RendererMap {\n  /**\n   * Construct a new renderer map.\n   *\n   * @param values - The initial values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   */\n  constructor(values: RendererMap.Values = {}, fallback?: CellRenderer) {\n    this._values = { ...values };\n    this._fallback = fallback || new TextRenderer();\n  }\n\n  /**\n   * A signal emitted when the renderer map has changed.\n   */\n  get changed(): ISignal<this, void> {\n    return this._changed;\n  }\n\n  /**\n   * Get the cell renderer to use for the given cell config.\n   *\n   * @param config - The cell config of interest.\n   *\n   * @returns The renderer to use for the cell.\n   */\n  get(config: CellRenderer.CellConfig): CellRenderer {\n    // Fetch the renderer from the values map.\n    let renderer = this._values[config.region];\n\n    // Execute a resolver function if necessary.\n    if (typeof renderer === 'function') {\n      try {\n        renderer = renderer(config);\n      } catch (err) {\n        renderer = undefined;\n        console.error(err);\n      }\n    }\n\n    // Return the renderer or the fallback.\n    return renderer || this._fallback;\n  }\n\n  /**\n   * Update the renderer map with new values\n   *\n   * @param values - The updated values for the map.\n   *\n   * @param fallback - The renderer of last resort.\n   *\n   * #### Notes\n   * This method always emits the `changed` signal.\n   */\n  update(values: RendererMap.Values = {}, fallback?: CellRenderer): void {\n    this._values = { ...this._values, ...values };\n    this._fallback = fallback || this._fallback;\n    this._changed.emit(undefined);\n  }\n\n  private _fallback: CellRenderer;\n  private _values: RendererMap.Values;\n  private _changed = new Signal<this, void>(this);\n}\n\n\n/**\n * The namespace for the `RendererMap` class statics.\n */\nexport\nnamespace RendererMap {\n  /**\n   * A type alias for a cell renderer resolver function.\n   */\n  export\n  type Resolver = CellRenderer.ConfigFunc<CellRenderer | undefined>;\n\n  /**\n   * A type alias for a `RendererMap` values type.\n   */\n  export\n  type Values = {\n    [R in DataModel.CellRegion]?: Resolver | CellRenderer | undefined;\n  };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n    ICellEditor,\n    CellEditor,\n    CellDataType,\n    ICellEditOptions,\n    TextCellEditor,\n    NumberCellEditor,\n    IntegerCellEditor,\n    BooleanCellEditor,\n    DateCellEditor,\n    OptionCellEditor,\n    DynamicOptionCellEditor,\n    ICellEditResponse\n} from './celleditor';\n\nimport {\n  DataModel, MutableDataModel\n} from './datamodel';\n\n/**\n * A type alias for cell editor override identifier.\n */\nexport\ntype EditorOverrideIdentifier = CellDataType | DataModel.Metadata | 'default';\n\n/**\n * An object which manages cell editing.\n */\nexport\ninterface ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(identifier: EditorOverrideIdentifier, editor: ICellEditor | Resolver): void;\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean;\n  /**\n   * Cancel editing.\n   */\n  cancel(): void;\n}\n\n/**\n * A type alias for a cell editor config function.\n *\n * This type is used to compute a value from a cell config object.\n */\nexport\ntype ConfigFunc<T> = (config: CellEditor.CellConfig) => T;\n\n/**\n * A type alias for a cell editor config option.\n *\n * A config option can be a static value or a config function.\n */\nexport\ntype ConfigOption<T> = T | ConfigFunc<T>;\n\n/**\n * A type alias for a cell editor resolver function.\n */\nexport\ntype Resolver = ConfigFunc<ICellEditor | undefined>;\n\n/**\n * Resolve a config option for a cell editor.\n *\n * @param option - The config option to resolve.\n *\n * @param config - The cell config object.\n *\n * @returns The resolved value for the option.\n */\nexport\nfunction resolveOption<T>(option: ConfigOption<T>, config: CellEditor.CellConfig): T {\n  return typeof option === 'function' ? (option as ConfigFunc<T>)(config) : option;\n}\n\n/**\n * An object which manages cell editing. It stores editor overrides,\n * decides which editor to use for a cell, makes sure there is only one editor active.\n */\nexport\nclass CellEditorController implements ICellEditorController {\n  /**\n   * Override cell editor for the cells matching the identifier.\n   *\n   * @param identifier - Cell identifier to use when matching cells.\n   * if identifier is a CellDataType, then cell matching is done using data type of the cell,\n   * if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,\n   * if identifier is 'default' then override is used as default editor when no other editor is found suitable\n   *\n   * @param editor - The cell editor to use or resolver to use to get an editor for matching cells.\n   */\n  setEditor(identifier: EditorOverrideIdentifier, editor: ICellEditor | Resolver) {\n    if (typeof identifier === 'string') {\n      this._typeBasedOverrides.set(identifier, editor);\n    } else {\n      const key = this._metadataIdentifierToKey(identifier);\n      this._metadataBasedOverrides.set(key, [identifier, editor]);\n    }\n  }\n\n  /**\n   * Start editing a cell.\n   *\n   * @param cell - The object holding cell configuration data.\n   *\n   * @param options - The cell editing options.\n   */\n  edit(cell: CellEditor.CellConfig, options?: ICellEditOptions): boolean {\n    const grid = cell.grid;\n\n    if (!grid.editable) {\n      console.error('Grid cannot be edited!');\n      return false;\n    }\n\n    this.cancel();\n\n    this._cell = cell;\n\n    options = options || {};\n    options.onCommit = options.onCommit || this._onCommit.bind(this);\n    options.onCancel = options.onCancel || this._onCancel.bind(this);\n\n    // if an editor is passed in with options, then use it for editing\n    if (options.editor) {\n      this._editor = options.editor;\n      options.editor.edit(cell, options);\n      return true;\n    }\n\n    // choose an editor based on overrides / cell data type\n    const editor = this._getEditor(cell);\n    if (editor) {\n      this._editor = editor;\n      editor.edit(cell, options);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Cancel editing.\n   */\n  cancel(): void {\n    if (this._editor) {\n      this._editor.cancel();\n      this._editor = null;\n    }\n\n    this._cell = null;\n  }\n\n  private _onCommit(response: ICellEditResponse): void {\n    const cell = this._cell;\n\n    if (!cell) {\n      return;\n    }\n\n    const grid = cell.grid;\n    const dataModel = grid.dataModel as MutableDataModel;\n    dataModel.setData('body', cell.row, cell.column, response.value);\n    grid.viewport.node.focus();\n    if (response.cursorMovement !== 'none') {\n      grid.moveCursor(response.cursorMovement);\n      grid.scrollToCursor();\n    }\n  }\n\n  private _onCancel(): void {\n    if (!this._cell) {\n      return;\n    }\n\n    this._cell.grid.viewport.node.focus();\n  }\n\n  private _getDataTypeKey(cell: CellEditor.CellConfig): string {\n    const metadata = cell.grid.dataModel ? cell.grid.dataModel.metadata('body', cell.row, cell.column) : null;\n\n    if (!metadata) {\n      return 'default';\n    }\n\n    let key = '';\n\n    if (metadata) {\n      key = metadata.type;\n    }\n\n    if (metadata.constraint && metadata.constraint.enum) {\n      if (metadata.constraint.enum === 'dynamic') {\n        key += ':dynamic-option';\n      } else {\n        key += ':option';\n      }\n    }\n\n    return key;\n  }\n\n  private _objectToKey(object: any): string {\n    let str = '';\n    for (let key in object) {\n      const value = object[key];\n      if (typeof value === 'object') {\n        str += `${key}:${this._objectToKey(value)}`;\n      } else {\n        str += `[${key}:${value}]`;\n      }\n    }\n\n    return str;\n  }\n\n  private _metadataIdentifierToKey(metadata: DataModel.Metadata): string {\n    return this._objectToKey(metadata);\n  }\n\n  private _metadataMatchesIdentifier(metadata: DataModel.Metadata, identifier: DataModel.Metadata): boolean {\n    for (let key in identifier) {\n      if (!metadata.hasOwnProperty(key)) {\n        return false;\n      }\n\n      const identifierValue = identifier[key];\n      const metadataValue = metadata[key];\n      if (typeof identifierValue === 'object') {\n        if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {\n          return false;\n        }\n      } else if (metadataValue !== identifierValue) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private _getMetadataBasedEditor(cell: CellEditor.CellConfig): ICellEditor | undefined {\n    let editorMatched: ICellEditor | undefined;\n    const metadata = cell.grid.dataModel!.metadata('body', cell.row, cell.column);\n    if (metadata) {\n      this._metadataBasedOverrides.forEach((value) => {\n        if (!editorMatched) {\n          let [identifier, editor] = value;\n          if (this._metadataMatchesIdentifier(metadata, identifier)) {\n            editorMatched = resolveOption(editor, cell);\n          }\n        }\n      });\n    }\n\n    return editorMatched;\n  }\n\n  /**\n   * Choose the most appropriate cell editor to use based on overrides / cell data type.\n   * \n   * If no match is found in overrides or based on cell data type, and if cell has a primitive\n   * data type then TextCellEditor is used as default cell editor. If 'default' cell editor\n   * is overridden, then it is used instead of TextCellEditor for default.\n   */\n  private _getEditor(cell: CellEditor.CellConfig): ICellEditor | undefined {\n    const dtKey = this._getDataTypeKey(cell);\n\n    // find an editor based on data type based override\n    if (this._typeBasedOverrides.has(dtKey)) {\n      const editor = this._typeBasedOverrides.get(dtKey);\n      return resolveOption(editor!, cell);\n    } // find an editor based on metadata match based override\n    else if (this._metadataBasedOverrides.size > 0) {\n      const editor = this._getMetadataBasedEditor(cell);\n      if (editor) {\n        return editor;\n      }\n    }\n\n    // choose an editor based on data type\n    switch (dtKey) {\n      case 'string':\n        return new TextCellEditor();\n      case 'number':\n        return new NumberCellEditor();\n      case 'integer':\n        return new IntegerCellEditor();\n      case 'boolean':\n        return new BooleanCellEditor();\n      case 'date':\n        return new DateCellEditor();\n      case 'string:option':\n      case 'number:option':\n      case 'integer:option':\n      case 'date:option':\n      case 'array:option':\n        return new OptionCellEditor();\n      case 'string:dynamic-option':\n      case 'number:dynamic-option':\n      case 'integer:dynamic-option':\n      case 'date:dynamic-option':\n        return new DynamicOptionCellEditor();\n    }\n\n    // if an override exists for 'default', then use it\n    if (this._typeBasedOverrides.has('default')) {\n      const editor = this._typeBasedOverrides.get('default');\n      return resolveOption(editor!, cell);\n    }\n\n    // if cell has a primitive data type then use TextCellEditor\n    const data = cell.grid.dataModel!.data('body', cell.row, cell.column);\n    if (!data || typeof data !== 'object') {\n      return new TextCellEditor();\n    }\n\n    // no suitable editor found for the cell\n    return undefined;\n  }\n\n  // active cell editor\n  private _editor: ICellEditor | null = null;\n  // active cell being edited\n  private _cell: CellEditor.CellConfig | null = null;\n  // cell editor overrides based on cell data type identifier\n  private _typeBasedOverrides: Map<string, ICellEditor | Resolver> = new Map();\n  // cell editor overrides based on partial metadata match\n  private _metadataBasedOverrides: Map<string, [DataModel.Metadata, ICellEditor | Resolver]> = new Map();\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  toArray\n} from '@lumino/algorithm';\n\nimport {\n  IDisposable\n} from '@lumino/disposable';\n\nimport {\n  ClipboardExt, ElementExt, Platform\n} from '@lumino/domutils';\n\nimport {\n  ConflatableMessage, IMessageHandler, Message, MessageLoop\n} from '@lumino/messaging';\n\nimport {\n  GridLayout, ScrollBar, Widget\n} from '@lumino/widgets';\n\nimport {\n  CellRenderer\n} from './cellrenderer';\n\nimport {\n  DataModel, MutableDataModel\n} from './datamodel';\n\nimport {\n  GraphicsContext\n} from './graphicscontext';\n\nimport {\n  RendererMap\n} from './renderermap';\n\nimport {\n  SectionList\n} from './sectionlist';\n\nimport {\n  SelectionModel\n} from './selectionmodel';\n\nimport {\n  ICellEditorController,\n  CellEditorController\n} from './celleditorcontroller';\n\n\n/**\n * A widget which implements a high-performance tabular data grid.\n *\n * #### Notes\n * A data grid is implemented as a composition of child widgets. These\n * child widgets are considered an implementation detail. Manipulating\n * the child widgets of a data grid directly is undefined behavior.\n *\n * This class is not designed to be subclassed.\n */\nexport\nclass DataGrid extends Widget {\n  /**\n   * Construct a new data grid.\n   *\n   * @param options - The options for initializing the data grid.\n   */\n  constructor(options: DataGrid.IOptions = {}) {\n    super();\n    this.addClass('lm-DataGrid');\n    /* <DEPRECATED> */\n    this.addClass('p-DataGrid');\n    /* </DEPRECATED> */\n\n    // Parse the simple options.\n    this._style = options.style || DataGrid.defaultStyle;\n    this._stretchLastRow = options.stretchLastRow || false;\n    this._stretchLastColumn = options.stretchLastColumn || false;\n    this._headerVisibility = options.headerVisibility || 'all';\n    this._cellRenderers = options.cellRenderers || new RendererMap();\n    this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;\n\n    // Connect to the renderer map changed signal.\n    this._cellRenderers.changed.connect(this._onRenderersChanged, this);\n\n    // Parse the default sizes.\n    let defaultSizes = options.defaultSizes || DataGrid.defaultSizes;\n    let minimumSizes = options.minimumSizes || DataGrid.minimumSizes;\n\n    // Set up the sections lists.\n    this._rowSections = new SectionList({ defaultSize: defaultSizes.rowHeight,\n      minimumSize: minimumSizes.rowHeight });\n    this._columnSections = new SectionList({ defaultSize: defaultSizes.columnWidth,\n      minimumSize: minimumSizes.columnWidth});\n    this._rowHeaderSections = new SectionList({ defaultSize: defaultSizes.rowHeaderWidth,\n      minimumSize: minimumSizes.rowHeaderWidth});\n    this._columnHeaderSections = new SectionList({ defaultSize: defaultSizes.columnHeaderHeight,\n      minimumSize: minimumSizes.columnHeaderHeight});\n\n    // Create the canvas, buffer, and overlay objects.\n    this._canvas = Private.createCanvas();\n    this._buffer = Private.createCanvas();\n    this._overlay = Private.createCanvas();\n\n    // Get the graphics contexts for the canvases.\n    this._canvasGC = this._canvas.getContext('2d')!;\n    this._bufferGC = this._buffer.getContext('2d')!;\n    this._overlayGC = this._overlay.getContext('2d')!;\n\n    // Set up the on-screen canvas.\n    this._canvas.style.position = 'absolute';\n    this._canvas.style.top = '0px';\n    this._canvas.style.left = '0px';\n    this._canvas.style.width = '0px';\n    this._canvas.style.height = '0px';\n\n    // Set up the on-screen overlay.\n    this._overlay.style.position = 'absolute';\n    this._overlay.style.top = '0px';\n    this._overlay.style.left = '0px';\n    this._overlay.style.width = '0px';\n    this._overlay.style.height = '0px';\n\n    // Create the internal widgets for the data grid.\n    this._viewport = new Widget();\n    this._viewport.node.tabIndex = -1;\n    this._viewport.node.style.outline = 'none';\n    this._vScrollBar = new ScrollBar({ orientation: 'vertical' });\n    this._hScrollBar = new ScrollBar({ orientation: 'horizontal' });\n    this._scrollCorner = new Widget();\n\n    this._editorController = new CellEditorController();\n\n    // Add the extra class names to the child widgets.\n    this._viewport.addClass('lm-DataGrid-viewport');\n    this._vScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._hScrollBar.addClass('lm-DataGrid-scrollBar');\n    this._scrollCorner.addClass('lm-DataGrid-scrollCorner');\n    /* <DEPRECATED> */\n    this._viewport.addClass('p-DataGrid-viewport');\n    this._vScrollBar.addClass('p-DataGrid-scrollBar');\n    this._hScrollBar.addClass('p-DataGrid-scrollBar');\n    this._scrollCorner.addClass('p-DataGrid-scrollCorner');\n    /* </DEPRECATED> */\n\n    // Add the on-screen canvas to the viewport node.\n    this._viewport.node.appendChild(this._canvas);\n\n    // Add the on-screen overlay to the viewport node.\n    this._viewport.node.appendChild(this._overlay);\n\n    // Install the message hooks.\n    MessageLoop.installMessageHook(this._viewport, this);\n    MessageLoop.installMessageHook(this._hScrollBar, this);\n    MessageLoop.installMessageHook(this._vScrollBar, this);\n\n    // Hide the scroll bars and corner from the outset.\n    this._vScrollBar.hide();\n    this._hScrollBar.hide();\n    this._scrollCorner.hide();\n\n    // Connect to the scroll bar signals.\n    this._vScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._hScrollBar.thumbMoved.connect(this._onThumbMoved, this);\n    this._vScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._hScrollBar.pageRequested.connect(this._onPageRequested, this);\n    this._vScrollBar.stepRequested.connect(this._onStepRequested, this);\n    this._hScrollBar.stepRequested.connect(this._onStepRequested, this);\n\n    // Set the layout cell config for the child widgets.\n    GridLayout.setCellConfig(this._viewport, { row: 0, column: 0 });\n    GridLayout.setCellConfig(this._vScrollBar, { row: 0, column: 1 });\n    GridLayout.setCellConfig(this._hScrollBar, { row: 1, column: 0 });\n    GridLayout.setCellConfig(this._scrollCorner, { row: 1, column: 1 });\n\n    // Create the layout for the data grid.\n    let layout = new GridLayout({\n      rowCount: 2,\n      columnCount: 2,\n      rowSpacing: 0,\n      columnSpacing: 0,\n      fitPolicy: 'set-no-constraint'\n    });\n\n    // Set the stretch factors for the grid.\n    layout.setRowStretch(0, 1);\n    layout.setRowStretch(1, 0);\n    layout.setColumnStretch(0, 1);\n    layout.setColumnStretch(1, 0);\n\n    // Add the child widgets to the layout.\n    layout.addWidget(this._viewport);\n    layout.addWidget(this._vScrollBar);\n    layout.addWidget(this._hScrollBar);\n    layout.addWidget(this._scrollCorner);\n\n    // Install the layout on the data grid.\n    this.layout = layout;\n  }\n\n  /**\n   * Dispose of the resources held by the widgets.\n   */\n  dispose(): void {\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Dispose of the handlers.\n    if (this._keyHandler) {\n      this._keyHandler.dispose();\n    }\n    if (this._mouseHandler) {\n      this._mouseHandler.dispose();\n    }\n    this._keyHandler = null;\n    this._mouseHandler = null;\n\n    // Clear the models.\n    this._dataModel = null;\n    this._selectionModel = null;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Dispose of the base class.\n    super.dispose();\n  }\n\n  /**\n   * Get the data model for the data grid.\n   */\n  get dataModel(): DataModel | null {\n    return this._dataModel;\n  }\n\n  /**\n   * Set the data model for the data grid.\n   *\n   * #### Notes\n   * This will automatically remove the current selection model.\n   */\n  set dataModel(value: DataModel | null) {\n    // Do nothing if the model does not change.\n    if (this._dataModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Clear the selection model.\n    this.selectionModel = null;\n\n    // Disconnect the change handler from the old model.\n    if (this._dataModel) {\n      this._dataModel.changed.disconnect(this._onDataModelChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onDataModelChanged, this);\n    }\n\n    // Update the internal model reference.\n    this._dataModel = value;\n\n    // Clear the section lists.\n    this._rowSections.clear();\n    this._columnSections.clear();\n    this._rowHeaderSections.clear();\n    this._columnHeaderSections.clear();\n\n    // Populate the section lists.\n    if (value) {\n      this._rowSections.insert(0, value.rowCount('body'));\n      this._columnSections.insert(0, value.columnCount('body'));\n      this._rowHeaderSections.insert(0, value.columnCount('row-header'));\n      this._columnHeaderSections.insert(0, value.rowCount('column-header'));\n    }\n\n    // Reset the scroll position.\n    this._scrollX = 0;\n    this._scrollY = 0;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the selection model for the data grid.\n   */\n  get selectionModel(): SelectionModel | null {\n    return this._selectionModel;\n  }\n\n  /**\n   * Set the selection model for the data grid.\n   */\n  set selectionModel(value: SelectionModel | null) {\n    // Do nothing if the selection model does not change.\n    if (this._selectionModel === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Ensure the data models are a match.\n    if (value && value.dataModel !== this._dataModel) {\n      throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');\n    }\n\n    // Disconnect the change handler from the old model.\n    if (this._selectionModel) {\n      this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);\n    }\n\n    // Connect the change handler for the new model.\n    if (value) {\n      value.changed.connect(this._onSelectionsChanged, this);\n    }\n\n    // Update the internal selection model reference.\n    this._selectionModel = value;\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the key handler for the data grid.\n   */\n  get keyHandler(): DataGrid.IKeyHandler | null {\n    return this._keyHandler;\n  }\n\n  /**\n   * Set the key handler for the data grid.\n   */\n  set keyHandler(value: DataGrid.IKeyHandler | null) {\n    this._keyHandler = value;\n  }\n\n  /**\n   * Get the mouse handler for the data grid.\n   */\n  get mouseHandler(): DataGrid.IMouseHandler | null {\n    return this._mouseHandler;\n  }\n\n  /**\n   * Set the mouse handler for the data grid.\n   */\n  set mouseHandler(value: DataGrid.IMouseHandler | null) {\n    // Bail early if the mouse handler does not change.\n    if (this._mouseHandler === value) {\n      return;\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n\n    // Update the internal mouse handler.\n    this._mouseHandler = value;\n  }\n\n  /**\n   * Get the style for the data grid.\n   */\n  get style(): DataGrid.Style {\n    return this._style;\n  }\n\n  /**\n   * Set the style for the data grid.\n   */\n  set style(value: DataGrid.Style) {\n    // Bail if the style does not change.\n    if (this._style === value) {\n      return;\n    }\n\n    // Update the internal style.\n    this._style = { ...value };\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n  }\n\n  /**\n   * Get the cell renderer map for the data grid.\n   */\n  get cellRenderers(): RendererMap {\n    return this._cellRenderers;\n  }\n\n  /**\n   * Set the cell renderer map for the data grid.\n   */\n  set cellRenderers(value: RendererMap) {\n    // Bail if the renderer map does not change.\n    if (this._cellRenderers === value) {\n      return;\n    }\n\n    // Disconnect the old map.\n    this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);\n\n    // Connect the new map.\n    value.changed.connect(this._onRenderersChanged, this);\n\n    // Update the internal renderer map.\n    this._cellRenderers = value;\n\n    // Schedule a repaint of the grid content.\n    this.repaintContent();\n  }\n\n  /**\n   * Get the header visibility for the data grid.\n   */\n  get headerVisibility(): DataGrid.HeaderVisibility {\n    return this._headerVisibility;\n  }\n\n  /**\n   * Set the header visibility for the data grid.\n   */\n  set headerVisibility(value: DataGrid.HeaderVisibility) {\n    // Bail if the visibility does not change.\n    if (this._headerVisibility === value) {\n      return;\n    }\n\n    // Update the internal visibility.\n    this._headerVisibility = value;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the default sizes for the various sections of the data grid.\n   */\n  get defaultSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.defaultSize;\n    let columnWidth = this._columnSections.defaultSize;\n    let rowHeaderWidth = this._rowHeaderSections.defaultSize;\n    let columnHeaderHeight = this._columnHeaderSections.defaultSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the default sizes for the various sections of the data grid.\n   */\n  set defaultSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.defaultSize = value.rowHeight;\n    this._columnSections.defaultSize = value.columnWidth;\n    this._rowHeaderSections.defaultSize = value.rowHeaderWidth;\n    this._columnHeaderSections.defaultSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the minimum sizes for the various sections of the data grid.\n   */\n  get minimumSizes(): DataGrid.DefaultSizes {\n    let rowHeight = this._rowSections.minimumSize;\n    let columnWidth = this._columnSections.minimumSize;\n    let rowHeaderWidth = this._rowHeaderSections.minimumSize;\n    let columnHeaderHeight = this._columnHeaderSections.minimumSize;\n    return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };\n  }\n\n  /**\n   * Set the minimum sizes for the various sections of the data grid.\n   */\n  set minimumSizes(value: DataGrid.DefaultSizes) {\n    // Update the section default sizes.\n    this._rowSections.minimumSize = value.rowHeight;\n    this._columnSections.minimumSize = value.columnWidth;\n    this._rowHeaderSections.minimumSize = value.rowHeaderWidth;\n    this._columnHeaderSections.minimumSize = value.columnHeaderHeight;\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Get the copy configuration for the data grid.\n   */\n  get copyConfig(): DataGrid.CopyConfig {\n    return this._copyConfig;\n  }\n\n  /**\n   * Set the copy configuration for the data grid.\n   */\n  set copyConfig(value: DataGrid.CopyConfig) {\n    this._copyConfig = value;\n  }\n\n  /**\n   * Get whether the last row is stretched.\n   */\n  get stretchLastRow(): boolean {\n    return this._stretchLastRow;\n  }\n\n  /**\n   * Set whether the last row is stretched.\n   */\n  set stretchLastRow(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastRow) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastRow = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * Get whether the last column is stretched.\n   */\n  get stretchLastColumn(): boolean {\n    return this._stretchLastColumn;\n  }\n\n  /**\n   * Set whether the last column is stretched.\n   */\n  set stretchLastColumn(value: boolean) {\n    // Bail early if the value does not change.\n    if (value === this._stretchLastColumn) {\n      return;\n    }\n\n    // Update the internal value.\n    this._stretchLastColumn = value;\n\n    // Sync the viewport\n    this._syncViewport();\n  }\n\n  /**\n   * The virtual width of the row headers.\n   */\n  get headerWidth(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'column') {\n      return 0;\n    }\n    return this._rowHeaderSections.length;\n  }\n\n  /**\n   * The virtual height of the column headers.\n   */\n  get headerHeight(): number {\n    if (this._headerVisibility === 'none') {\n      return 0;\n    }\n    if (this._headerVisibility === 'row') {\n      return 0;\n    }\n    return this._columnHeaderSections.length;\n  }\n\n  /**\n   * The virtual width of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get bodyWidth(): number {\n    return this._columnSections.length;\n  }\n\n  /**\n   * The virtual height of the grid body.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get bodyHeight(): number {\n    return this._rowSections.length;\n  }\n\n  /**\n   * The virtual width of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last column.\n   */\n  get totalWidth(): number {\n    return this.headerWidth + this.bodyWidth;\n  }\n\n  /**\n   * The virtual height of the entire grid.\n   *\n   * #### Notes\n   * This does *not* account for a stretched last row.\n   */\n  get totalHeight(): number {\n    return this.headerHeight + this.bodyHeight;\n  }\n\n  /**\n   * The actual width of the viewport.\n   */\n  get viewportWidth(): number {\n    return this._viewportWidth;\n  }\n\n  /**\n   * The actual height of the viewport.\n   */\n  get viewportHeight(): number {\n    return this._viewportHeight;\n  }\n\n  /**\n   * The width of the visible portion of the grid body.\n   */\n  get pageWidth(): number {\n    return Math.max(0, this.viewportWidth - this.headerWidth);\n  }\n\n  /**\n   * The height of the visible portion of the grid body.\n   */\n  get pageHeight(): number {\n    return Math.max(0, this.viewportHeight - this.headerHeight);\n  }\n\n  /**\n   * The current scroll X position of the viewport.\n   */\n  get scrollX(): number {\n    return this._hScrollBar.value;\n  }\n\n  /**\n   * The current scroll Y position of the viewport.\n   */\n  get scrollY(): number {\n    return this._vScrollBar.value;\n  }\n\n  /**\n   * The maximum scroll X position for the grid.\n   */\n  get maxScrollX(): number {\n    return Math.max(0, this.bodyWidth - this.pageWidth - 1);\n  }\n\n  /**\n   * The maximum scroll Y position for the grid.\n   */\n  get maxScrollY(): number {\n    return Math.max(0, this.bodyHeight - this.pageHeight - 1);\n  }\n\n  /**\n   * The viewport widget for the data grid.\n   */\n  get viewport(): Widget {\n    return this._viewport;\n  }\n\n  /**\n   * The cell editor controller object for the data grid.\n   */\n  get editorController(): ICellEditorController | null {\n    return this._editorController;\n  }\n\n  set editorController(controller: ICellEditorController | null) {\n    this._editorController = controller;\n  }\n\n  /**\n   * Whether the cell editing is enabled for the data grid.\n   */\n  get editingEnabled(): boolean {\n    return this._editingEnabled;\n  }\n\n  set editingEnabled(enabled: boolean) {\n    this._editingEnabled = enabled;\n  }\n\n  /**\n   * Whether the grid cells are editable.\n   *\n   * `editingEnabled` flag must be on and grid must have required\n   * selection model, editor controller and data model properties.\n   */\n  get editable(): boolean {\n    return this._editingEnabled &&\n      this._selectionModel !== null &&\n      this._editorController !== null &&\n      this.dataModel instanceof MutableDataModel;\n  }\n\n  /**\n   * The rendering context for painting the data grid.\n   */\n  protected get canvasGC(): CanvasRenderingContext2D {\n    return this._canvasGC;\n  }\n\n  /**\n   * The row sections of the data grid.\n   */\n  protected get rowSections(): SectionList {\n    return this._rowSections;\n  }\n\n  /**\n   * The column sections of the data grid.\n   */\n  protected get columnSections(): SectionList {\n    return this._columnSections;\n  }\n\n  /**\n   * The row header sections of the data grid.\n   */\n  protected get rowHeaderSections(): SectionList {\n    return this._rowHeaderSections;\n  }\n\n  /**\n   * The column header sections of the data grid.\n   */\n  protected get columnHeaderSections(): SectionList {\n    return this._columnHeaderSections;\n  }\n\n  /**\n   * Scroll the grid to the specified row.\n   *\n   * @param row - The row index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the row is already visible.\n   */\n  scrollToRow(row: number): void {\n    // Fetch the row count.\n    let nr = this._rowSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0) {\n      return;\n    }\n\n    // Floor the row index.\n    row = Math.floor(row);\n\n    // Clamp the row index.\n    row = Math.max(0, Math.min(row, nr - 1));\n\n    // Get the virtual bounds of the row.\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dy = 0;\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(0, dy);\n  }\n\n  /**\n   * Scroll the grid to the specified column.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the column is already visible.\n   */\n  scrollToColumn(column: number): void {\n    // Fetch the column count.\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nc === 0) {\n      return;\n    }\n\n    // Floor the column index.\n    column = Math.floor(column);\n\n    // Clamp the column index.\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the column.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, 0);\n  }\n\n  /**\n   * Scroll the grid to the specified cell.\n   *\n   * @param row - The row index of the cell.\n   *\n   * @param column - The column index of the cell.\n   *\n   * #### Notes\n   * This is a no-op if the cell is already visible.\n   */\n  scrollToCell(row: number, column: number): void {\n    // Fetch the row and column count.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n\n    // Bail early if there is no content.\n    if (nr === 0 || nc === 0) {\n      return;\n    }\n\n    // Floor the cell index.\n    row = Math.floor(row);\n    column = Math.floor(column);\n\n    // Clamp the cell index.\n    row = Math.max(0, Math.min(row, nr - 1));\n    column = Math.max(0, Math.min(column, nc - 1));\n\n    // Get the virtual bounds of the cell.\n    let x1 = this._columnSections.offsetOf(column);\n    let x2 = this._columnSections.extentOf(column);\n    let y1 = this._rowSections.offsetOf(row);\n    let y2 = this._rowSections.extentOf(row);\n\n    // Get the virtual bounds of the viewport.\n    let vx1 = this._scrollX;\n    let vx2 = this._scrollX + this.pageWidth - 1;\n    let vy1 = this._scrollY;\n    let vy2 = this._scrollY + this.pageHeight - 1;\n\n    // Set up the delta variables.\n    let dx = 0;\n    let dy = 0;\n\n    // Compute the delta X scroll.\n    if (x1 < vx1) {\n      dx = x1 - vx1 - 10;\n    } else if (x2 > vx2) {\n      dx = x2 - vx2 + 10;\n    }\n\n    // Compute the delta Y scroll.\n    if (y1 < vy1) {\n      dy = y1 - vy1 - 10;\n    } else if (y2 > vy2) {\n      dy = y2 - vy2 + 10;\n    }\n\n    // Bail early if no scroll is needed.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Scroll by the computed delta.\n    this.scrollBy(dx, dy);\n  }\n\n  /**\n   * Move cursor down/up/left/right while making sure it remains\n   * within the bounds of selected rectangles\n   *\n   * @param direction - The direction of the movement.\n   */\n  moveCursor(direction: SelectionModel.CursorMoveDirection): void {\n    // Bail early if there is no selection\n    if (!this.dataModel ||\n      !this._selectionModel ||\n      this._selectionModel.isEmpty) {\n      return;\n    }\n\n    const iter = this._selectionModel.selections();\n    const onlyOne = iter.next() && !iter.next();\n\n    // if there is a single selection that is a single cell selection\n    // then move the selection and cursor within grid bounds\n    if (onlyOne) {\n      const currentSel = this._selectionModel.currentSelection()!;\n      if (currentSel.r1 === currentSel.r2 &&\n        currentSel.c1 === currentSel.c2\n      ) {\n        const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;\n        const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;\n        let newRow = currentSel.r1 + dr;\n        let newColumn = currentSel.c1 + dc;\n        const rowCount = this.dataModel.rowCount('body');\n        const columnCount = this.dataModel.columnCount('body');\n        if (newRow >= rowCount) {\n          newRow = 0;\n          newColumn += 1;\n        } else if (newRow === -1) {\n          newRow = rowCount - 1;\n          newColumn -= 1;\n        }\n        if (newColumn >= columnCount) {\n          newColumn = 0;\n          newRow += 1;\n          if (newRow >= rowCount) {\n            newRow = 0;\n          }\n        } else if (newColumn === -1) {\n          newColumn = columnCount - 1;\n          newRow -= 1;\n          if (newRow === -1) {\n            newRow = rowCount - 1;\n          }\n        }\n\n        this._selectionModel.select({\n          r1: newRow, c1: newColumn,\n          r2: newRow, c2: newColumn,\n          cursorRow: newRow, cursorColumn: newColumn,\n          clear: 'all'\n        });\n\n        return;\n      }\n    }\n\n    // if there are multiple selections, move cursor\n    // within selection rectangles\n    this._selectionModel.moveCursorWithinSelections(direction);\n  }\n\n  /**\n   * Scroll the grid to the current cursor position.\n   *\n   * #### Notes\n   * This is a no-op if the cursor is already visible or\n   * if there is no selection model installed on the grid.\n   */\n  scrollToCursor(): void {\n    // Bail early if there is no selection model.\n    if (!this._selectionModel) {\n      return;\n    }\n\n    // Fetch the cursor row and column.\n    let row = this._selectionModel.cursorRow;\n    let column = this._selectionModel.cursorColumn;\n\n    // Scroll to the cursor cell.\n    this.scrollToCell(row, column);\n  }\n\n  /**\n   * Scroll the viewport by the specified amount.\n   *\n   * @param dx - The X scroll amount.\n   *\n   * @param dy - The Y scroll amount.\n   */\n  scrollBy(dx: number, dy: number): void {\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one page.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByPage(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let dx = 0;\n    let dy = 0;\n    switch (dir) {\n    case 'up':\n      dy = -this.pageHeight;\n      break;\n    case 'down':\n      dy = this.pageHeight;\n      break;\n    case 'left':\n      dx = -this.pageWidth;\n      break;\n    case 'right':\n      dx = this.pageWidth;\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.scrollTo(this.scrollX + dx, this.scrollY + dy);\n  }\n\n  /**\n   * Scroll the viewport by one cell-aligned step.\n   *\n   * @param dir - The desired direction of the scroll.\n   */\n  scrollByStep(dir: 'up' | 'down' | 'left' | 'right'): void {\n    let r: number;\n    let c: number;\n    let x = this.scrollX;\n    let y = this.scrollY;\n    let rows = this._rowSections;\n    let columns = this._columnSections;\n    switch (dir) {\n    case 'up':\n      r = rows.indexOf(y - 1);\n      y = r < 0 ? y : rows.offsetOf(r);\n      break;\n    case 'down':\n      r = rows.indexOf(y);\n      y = r < 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);\n      break;\n    case 'left':\n      c = columns.indexOf(x - 1);\n      x = c < 0 ? x : columns.offsetOf(c);\n      break;\n    case 'right':\n      c = columns.indexOf(x);\n      x = c < 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.scrollTo(x, y);\n  }\n\n  /**\n   * Scroll to the specified offset position.\n   *\n   * @param x - The desired X position.\n   *\n   * @param y - The desired Y position.\n   */\n  scrollTo(x: number, y: number): void {\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Update the scroll bar values with the desired position.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Post a scroll request message to the viewport.\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Get the row count for a particular region in the data grid.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns The row count for the specified region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._rowSections.count;\n    } else {\n      count = this._columnHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the column count for a particular region in the data grid.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns The column count for the specified region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    let count: number;\n    if (region === 'body') {\n      count = this._columnSections.count;\n    } else {\n      count = this._rowHeaderSections.count;\n    }\n    return count;\n  }\n\n  /**\n   * Get the row at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param offset - The virtual offset of the row of interest.\n   *\n   * @returns The index of the row, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowAt(region: DataModel.RowRegion, offset: number): number {\n    // Bail early if the offset is negative.\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._rowSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Bail early if no row stretching is required.\n    if (ph <= bh) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= ph) {\n      return -1;\n    }\n\n    // Otherwise, return the last row.\n    return this._rowSections.count - 1;\n  }\n\n  /**\n   * Get the column at a virtual offset in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param offset - The virtual offset of the column of interest.\n   *\n   * @returns The index of the column, or `-1` if the offset is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnAt(region: DataModel.ColumnRegion, offset: number): number {\n    if (offset < 0) {\n      return -1;\n    }\n\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.indexOf(offset);\n    }\n\n    // Fetch the index.\n    let index = this._columnSections.indexOf(offset);\n\n    // Return early if the section is found.\n    if (index >= 0) {\n      return index;\n    }\n\n    // Bail early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return -1;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Bail early if no column stretching is required.\n    if (pw <= bw) {\n      return -1;\n    }\n\n    // Bail early if the offset is out of bounds.\n    if (offset >= pw) {\n      return -1;\n    }\n\n    // Otherwise, return the last column.\n    return this._columnSections.count - 1;\n  }\n\n  /**\n   * Get the offset of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The offset of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last row has no effect on the return value.\n   */\n  rowOffset(region: DataModel.RowRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._rowSections.offsetOf(index);\n    } else {\n      offset = this._columnHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the offset of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The offset of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * A stretched last column has no effect on the return value.\n   */\n  columnOffset(region: DataModel.ColumnRegion, index: number): number {\n    let offset: number;\n    if (region === 'body') {\n      offset = this._columnSections.offsetOf(index);\n    } else {\n      offset = this._rowHeaderSections.offsetOf(index);\n    }\n    return offset;\n  }\n\n  /**\n   * Get the size of a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @returns The size of the row, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row.\n   */\n  rowSize(region: DataModel.RowRegion, index: number): number {\n    // Return early for the column header region.\n    if (region === 'column-header') {\n      return this._columnHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the row size.\n    let size = this._rowSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last row is not stretched.\n    if (!this._stretchLastRow) {\n      return size;\n    }\n\n    // Return early if its not the last row.\n    if (index < this._rowSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Return early if no stretching is needed.\n    if (ph <= bh) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (ph - bh);\n  }\n\n  /**\n   * Get the size of a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @returns The size of the column, or `-1` if the index is out of range.\n   *\n   * #### Notes\n   * This method accounts for a stretched last column.\n   */\n  columnSize(region: DataModel.ColumnRegion, index: number): number {\n    // Return early for the row header region.\n    if (region === 'row-header') {\n      return this._rowHeaderSections.sizeOf(index);\n    }\n\n    // Fetch the column size.\n    let size = this._columnSections.sizeOf(index);\n\n    // Bail early if the index is out of bounds.\n    if (size < 0) {\n      return size;\n    }\n\n    // Return early if the last column is not stretched.\n    if (!this._stretchLastColumn) {\n      return size;\n    }\n\n    // Return early if its not the last column.\n    if (index < this._columnSections.count - 1) {\n      return size;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Return early if no stretching is needed.\n    if (pw <= bw) {\n      return size;\n    }\n\n    // Return the adjusted size.\n    return size + (pw - bw);\n  }\n\n  /**\n   * Resize a row in the data grid.\n   *\n   * @param region - The region which holds the row of interest.\n   *\n   * @param index - The index of the row of interest.\n   *\n   * @param size - The desired size of the row.\n   */\n  resizeRow(region: DataModel.RowRegion, index: number, size: number): void {\n    let msg = new Private.RowResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Resize a column in the data grid.\n   *\n   * @param region - The region which holds the column of interest.\n   *\n   * @param index - The index of the column of interest.\n   *\n   * @param size - The desired size of the column.\n   */\n  resizeColumn(region: DataModel.ColumnRegion, index: number, size: number): void {\n    let msg = new Private.ColumnResizeRequest(region, index, size);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Reset modified rows to their default size.\n   *\n   * @param region - The row region of interest.\n   */\n  resetRows(region: DataModel.RowRegion | 'all'): void {\n    switch (region) {\n    case 'all':\n      this._rowSections.reset();\n      this._columnHeaderSections.reset();\n      break;\n    case 'body':\n      this._rowSections.reset();\n      break;\n    case 'column-header':\n      this._columnHeaderSections.reset();\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Reset modified columns to their default size.\n   *\n   * @param region - The column region of interest.\n   */\n  resetColumns(region: DataModel.ColumnRegion | 'all'): void {\n    switch (region) {\n    case 'all':\n      this._columnSections.reset();\n      this._rowHeaderSections.reset();\n      break;\n    case 'body':\n      this._columnSections.reset();\n      break;\n    case 'row-header':\n      this._rowHeaderSections.reset();\n      break;\n    default:\n      throw 'unreachable';\n    }\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * Map a client position to local viewport coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The local viewport coordinates for the position.\n   */\n  mapToLocal(clientX: number, clientY: number): { lx: number, ly: number } {\n    // Fetch the viewport rect.\n    let rect = this._viewport.node.getBoundingClientRect();\n\n    // Extract the rect coordinates.\n    let { left, top } = rect;\n\n    // Round the rect coordinates for sub-pixel positioning.\n    left = Math.floor(left);\n    top = Math.floor(top);\n\n    // Convert to local coordinates.\n    let lx = clientX - left;\n    let ly = clientY - top;\n\n    // Return the local coordinates.\n    return { lx, ly };\n  }\n\n  /**\n   * Map a client position to virtual grid coordinates.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The virtual grid coordinates for the position.\n   */\n  mapToVirtual(clientX: number, clientY: number): { vx: number, vy: number } {\n    // Convert to local coordiates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Convert to virtual coordinates.\n    let vx = lx + this.scrollX - this.headerWidth;\n    let vy = ly + this.scrollY - this.headerHeight;\n\n    // Return the local coordinates.\n    return { vx, vy };\n  }\n\n  /**\n   * Hit test the viewport for the given client position.\n   *\n   * @param clientX - The client X position of the mouse.\n   *\n   * @param clientY - The client Y position of the mouse.\n   *\n   * @returns The hit test result, or `null` if the client\n   *   position is out of bounds.\n   *\n   * #### Notes\n   * This method accounts for a stretched last row and/or column.\n   */\n  hitTest(clientX: number, clientY: number): DataGrid.HitTestResult {\n    // Convert the mouse position into local coordinates.\n    let { lx, ly } = this.mapToLocal(clientX, clientY);\n\n    // Fetch the header and body dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Adjust the body width for a stretched last column.\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Adjust the body height for a stretched last row.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n\n    // Check for a corner header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < hh) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx;\n      let vy = ly;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'corner-header', row, column, x, y, width, height };\n    }\n\n    // Check for a column header hit.\n    if (ly >= 0 && ly < hh && lx >= 0 && lx < (hw + bw)) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw;\n      let vy = ly\n\n      // Fetch the row and column index.\n      let row = this.rowAt('column-header', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('column-header', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('column-header', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'column-header', row, column, x, y, width, height };\n    }\n\n    // Check for a row header hit.\n    if (lx >= 0 && lx < hw && ly >= 0 && ly < (hh + bh)) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('row-header', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('row-header', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('row-header', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the leading and trailing positions.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the hit test result.\n      return { region: 'row-header', row, column, x, y, width, height };\n    }\n\n    // Check for a body hit.\n    if (lx >= hw && lx < (hw + bw) && ly >= hh && ly < (hh + bh)) {\n      // Convert to unscrolled virtual coordinates.\n      let vx = lx + this._scrollX - hw\n      let vy = ly + this._scrollY - hh;\n\n      // Fetch the row and column index.\n      let row = this.rowAt('body', vy);\n      let column = this.columnAt('body', vx);\n\n      // Fetch the cell offset position.\n      let ox = this.columnOffset('body', column);\n      let oy = this.rowOffset('body', row);\n\n      // Fetch the cell width and height.\n      let width = this.columnSize('body', column);\n      let height = this.rowSize('body', row);\n\n      // Compute the part coordinates.\n      let x = vx - ox;\n      let y = vy - oy;\n\n      // Return the result.\n      return { region: 'body', row, column, x, y, width, height };\n    }\n\n    // Otherwise, it's a void space hit.\n    let row = -1;\n    let column = -1;\n    let x = -1;\n    let y = -1;\n    let width = -1;\n    let height = -1;\n\n    // Return the hit test result.\n    return { region: 'void', row, column, x, y, width, height };\n  }\n\n  /**\n   * Copy the current selection to the system clipboard.\n   *\n   * #### Notes\n   * The grid must have a data model and a selection model.\n   *\n   * The behavior can be configured via `DataGrid.copyConfig`.\n   */\n  copyToClipboard(): void {\n    // Fetch the data model.\n    let dataModel = this._dataModel;\n\n    // Bail early if there is no data model.\n    if (!dataModel) {\n      return;\n    }\n\n    // Fetch the selection model.\n    let selectionModel = this._selectionModel;\n\n    // Bail early if there is no selection model.\n    if (!selectionModel) {\n      return;\n    }\n\n    // Coerce the selections to an array.\n    let selections = toArray(selectionModel.selections());\n\n    // Bail early if there are no selections.\n    if (selections.length === 0) {\n      return;\n    }\n\n    // Alert that multiple selections cannot be copied.\n    if (selections.length > 1) {\n      alert('Cannot copy multiple grid selections.');\n      return;\n    }\n\n    // Fetch the model counts.\n    let br = dataModel.rowCount('body');\n    let bc = dataModel.columnCount('body');\n\n    // Bail early if there is nothing to copy.\n    if (br === 0 || bc === 0) {\n      return;\n    }\n\n    // Unpack the selection.\n    let { r1, c1, r2, c2 } = selections[0];\n\n    // Clamp the selection to the model bounds.\n    r1 = Math.max(0, Math.min(r1, br - 1));\n    c1 = Math.max(0, Math.min(c1, bc - 1));\n    r2 = Math.max(0, Math.min(r2, br - 1));\n    c2 = Math.max(0, Math.min(c2, bc - 1));\n\n    // Ensure the limits are well-orderd.\n    if (r2 < r1) [r1, r2] = [r2, r1];\n    if (c2 < c1) [c1, c2] = [c2, c1];\n\n    // Fetch the header counts.\n    let rhc = dataModel.columnCount('row-header');\n    let chr = dataModel.rowCount('column-header');\n\n    // Unpack the copy config.\n    let separator = this._copyConfig.separator;\n    let format = this._copyConfig.format;\n    let headers = this._copyConfig.headers;\n    let warningThreshold = this._copyConfig.warningThreshold;\n\n    // Compute the number of cells to be copied.\n    let rowCount = r2 - r1 + 1;\n    let colCount = c2 - c1 + 1;\n    switch (headers) {\n    case 'none':\n      rhc = 0;\n      chr = 0;\n      break;\n    case 'row':\n      chr = 0;\n      colCount += rhc;\n      break;\n    case 'column':\n      rhc = 0;\n      rowCount += chr;\n      break;\n    case 'all':\n      rowCount += chr;\n      colCount += rhc;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Compute the total cell count.\n    let cellCount = rowCount * colCount;\n\n    // Allow the user to cancel a large copy request.\n    if (cellCount > warningThreshold) {\n      let msg = `Copying ${cellCount} cells may take a while. Continue?`;\n      if (!window.confirm(msg)) {\n        return;\n      }\n    }\n\n    // Set up the format args.\n    let args = {\n      region: 'body' as DataModel.CellRegion,\n      row: 0,\n      column: 0,\n      value: null as any,\n      metadata: {} as DataModel.Metadata\n    };\n\n    // Allocate the array of rows.\n    let rows = new Array<string[]>(rowCount);\n\n    // Iterate over the rows.\n    for (let j = 0; j < rowCount; ++j) {\n      // Allocate the array of cells.\n      let cells = new Array<string>(colCount);\n\n      // Iterate over the columns.\n      for (let i = 0; i < colCount; ++i) {\n        // Set up the format variables.\n        let region: DataModel.CellRegion;\n        let row: number;\n        let column: number;\n\n        // Populate the format variables.\n        if (j < chr && i < rhc) {\n          region = 'corner-header';\n          row = j;\n          column = i;\n        } else if (j < chr) {\n          region = 'column-header';\n          row = j;\n          column = i - rhc + c1;\n        } else if (i < rhc) {\n          region = 'row-header';\n          row = j - chr + r1;\n          column = i;\n        } else {\n          region = 'body';\n          row = j - chr + r1;\n          column = i - rhc + c1;\n        }\n\n        // Populate the format args.\n        args.region = region;\n        args.row = row;\n        args.column = column;\n        args.value = dataModel.data(region, row, column);\n        args.metadata = dataModel.metadata(region, row, column);\n\n        // Format the cell.\n        cells[i] = format(args);\n      }\n\n      // Save the row of cells.\n      rows[j] = cells;\n    }\n\n    // Convert the cells into lines.\n    let lines = rows.map(cells => cells.join(separator));\n\n    // Convert the lines into text.\n    let text = lines.join('\\n');\n\n    // Copy the text to the clipboard.\n    ClipboardExt.copyText(text);\n  }\n\n  /**\n   * Process a message sent to the widget.\n   *\n   * @param msg - The message sent to the widget.\n   */\n  processMessage(msg: Message): void {\n    // Ignore child show/hide messages. The data grid controls the\n    // visibility of its children, and will manually dispatch the\n    // fit-request messages as a result of visibility change.\n    if (msg.type === 'child-shown' || msg.type === 'child-hidden') {\n      return;\n    }\n\n    // Recompute the scroll bar minimums before the layout refits.\n    if (msg.type === 'fit-request') {\n      let vsbLimits = ElementExt.sizeLimits(this._vScrollBar.node);\n      let hsbLimits = ElementExt.sizeLimits(this._hScrollBar.node);\n      this._vScrollBarMinWidth = vsbLimits.minWidth;\n      this._hScrollBarMinHeight = hsbLimits.minHeight;\n    }\n\n    // Process all other messages as normal.\n    super.processMessage(msg);\n  }\n\n  /**\n   * Intercept a message sent to a message handler.\n   *\n   * @param handler - The target handler of the message.\n   *\n   * @param msg - The message to be sent to the handler.\n   *\n   * @returns `true` if the message should continue to be processed\n   *   as normal, or `false` if processing should cease immediately.\n   */\n  messageHook(handler: IMessageHandler, msg: Message): boolean {\n    // Process viewport messages.\n    if (handler === this._viewport) {\n      this._processViewportMessage(msg);\n      return true;\n    }\n\n    // Process horizontal scroll bar messages.\n    if (handler === this._hScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Process vertical scroll bar messages.\n    if (handler === this._vScrollBar && msg.type === 'activate-request') {\n      this.activate();\n      return false;\n    }\n\n    // Ignore all other messages.\n    return true;\n  }\n\n  /**\n   * Handle the DOM events for the data grid.\n   *\n   * @param event - The DOM event sent to the data grid.\n   *\n   * #### Notes\n   * This method implements the DOM `EventListener` interface and is\n   * called in response to events on the data grid's DOM node. It\n   * should not be called directly by user code.\n   */\n  handleEvent(event: Event): void {\n    switch (event.type) {\n    case 'keydown':\n      this._evtKeyDown(event as KeyboardEvent);\n      break;\n    case 'mousedown':\n      this._evtMouseDown(event as MouseEvent);\n      break;\n    case 'mousemove':\n      this._evtMouseMove(event as MouseEvent);\n      break;\n    case 'mouseup':\n      this._evtMouseUp(event as MouseEvent);\n      break;\n    case 'dblclick':\n      this._evtMouseDoubleClick(event as MouseEvent);\n      break;\n    case 'mouseleave':\n      this._evtMouseLeave(event as MouseEvent);\n      break;\n    case 'contextmenu':\n      this._evtContextMenu(event as MouseEvent);\n      break;\n    case 'wheel':\n      this._evtWheel(event as WheelEvent);\n      break;\n    case 'resize':\n      this._refreshDPI();\n      break;\n    }\n  }\n\n  /**\n   * A message handler invoked on an `'activate-request'` message.\n   */\n  protected onActivateRequest(msg: Message): void {\n    this.viewport.node.focus();\n  }\n\n  /**\n   * A message handler invoked on a `'before-attach'` message.\n   */\n  protected onBeforeAttach(msg: Message): void {\n    window.addEventListener('resize', this);\n    this.node.addEventListener('wheel', this);\n    this._viewport.node.addEventListener('keydown', this);\n    this._viewport.node.addEventListener('mousedown', this);\n    this._viewport.node.addEventListener('mousemove', this);\n    this._viewport.node.addEventListener('dblclick', this);\n    this._viewport.node.addEventListener('mouseleave', this);\n    this._viewport.node.addEventListener('contextmenu', this);\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on an `'after-detach'` message.\n   */\n  protected onAfterDetach(msg: Message): void {\n    window.removeEventListener('resize', this);\n    this.node.removeEventListener('wheel', this);\n    this._viewport.node.removeEventListener('keydown', this);\n    this._viewport.node.removeEventListener('mousedown', this);\n    this._viewport.node.removeEventListener('mousemove', this);\n    this._viewport.node.removeEventListener('mouseleave', this);\n    this._viewport.node.removeEventListener('dblclick', this);\n    this._viewport.node.removeEventListener('contextmenu', this);\n    this._releaseMouse();\n  }\n\n  /**\n   * A message handler invoked on a `'before-show'` message.\n   */\n  protected onBeforeShow(msg: Message): void {\n    this.repaintContent();\n    this.repaintOverlay();\n  }\n\n  /**\n   * A message handler invoked on a `'resize'` message.\n   */\n  protected onResize(msg: Widget.ResizeMessage): void {\n    if (this._editorController) {\n      this._editorController.cancel();\n    }\n\n    this._syncScrollState();\n  }\n\n  /**\n   * Schedule a repaint of all of the grid content.\n   */\n  protected repaintContent(): void {\n    let msg = new Private.PaintRequest('all', 0, 0, 0, 0);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of specific grid content.\n   */\n  protected repaintRegion(region: DataModel.CellRegion, r1: number, c1: number, r2: number, c2: number): void {\n    let msg = new Private.PaintRequest(region, r1, c1, r2, c2);\n    MessageLoop.postMessage(this._viewport, msg);\n  }\n\n  /**\n   * Schedule a repaint of the overlay.\n   */\n  protected repaintOverlay(): void {\n    MessageLoop.postMessage(this._viewport, Private.OverlayPaintRequest);\n  }\n\n  /**\n   * Ensure the canvas is at least the specified size.\n   *\n   * This method will retain the valid canvas content.\n   */\n  private _resizeCanvasIfNeeded(width: number, height: number): void {\n    // Scale the size by the dpi ratio.\n    width = width * this._dpiRatio;\n    height = height * this._dpiRatio;\n\n    // Compute the maximum canvas size for the given width and height.\n    let maxW = (Math.ceil((width + 1) / 512) + 1) * 512;\n    let maxH = (Math.ceil((height + 1) / 512) + 1) * 512;\n\n    // Get the current size of the canvas.\n    let curW = this._canvas.width;\n    let curH = this._canvas.height;\n\n    // Bail early if the canvas size is within bounds.\n    if (curW >= width && curH >= height && curW <= maxW && curH <= maxH) {\n      return;\n    }\n\n    // Compute the expanded canvas size.\n    let expW = maxW - 512;\n    let expH = maxH - 512;\n\n    // Set the transforms to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);\n    this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Resize the buffer if needed.\n    if (curW < width) {\n      this._buffer.width = expW;\n    } else if (curW > maxW) {\n      this._buffer.width = maxW;\n    }\n\n    // Resize the buffer height if needed.\n    if (curH < height) {\n      this._buffer.height = expH;\n    } else if (curH > maxH) {\n      this._buffer.height = maxH;\n    }\n\n    // Test whether there is content to blit.\n    let needBlit = curH > 0 && curH > 0 && width > 0 && height > 0;\n\n    // Copy the valid canvas content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._canvas, 0, 0);\n    }\n\n    // Resize the canvas width if needed.\n    if (curW < width) {\n      this._canvas.width = expW;\n      this._canvas.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._canvas.width = maxW;\n      this._canvas.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the canvas height if needed.\n    if (curH < height) {\n      this._canvas.height = expH;\n      this._canvas.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._canvas.height = maxH;\n      this._canvas.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid canvas content from the buffer if needed.\n    if (needBlit) {\n      this._canvasGC.drawImage(this._buffer, 0, 0);\n    }\n\n    // Copy the valid overlay content into the buffer if needed.\n    if (needBlit) {\n      this._bufferGC.drawImage(this._overlay, 0, 0);\n    }\n\n    // Resize the overlay width if needed.\n    if (curW < width) {\n      this._overlay.width = expW;\n      this._overlay.style.width = `${expW / this._dpiRatio}px`;\n    } else if (curW > maxW) {\n      this._overlay.width = maxW;\n      this._overlay.style.width = `${maxW / this._dpiRatio}px`;\n    }\n\n    // Resize the overlay height if needed.\n    if (curH < height) {\n      this._overlay.height = expH;\n      this._overlay.style.height = `${expH / this._dpiRatio}px`;\n    } else if (curH > maxH) {\n      this._overlay.height = maxH;\n      this._overlay.style.height = `${maxH / this._dpiRatio}px`;\n    }\n\n    // Copy the valid overlay content from the buffer if needed.\n    if (needBlit) {\n      this._overlayGC.drawImage(this._buffer, 0, 0);\n    }\n  }\n\n  /**\n   * Sync the scroll bars and scroll state with the viewport.\n   *\n   * #### Notes\n   * If the visibility of either scroll bar changes, a synchronous\n   * fit-request will be dispatched to the data grid to immediately\n   * resize the viewport.\n   */\n  private _syncScrollState(): void {\n    // Fetch the viewport dimensions.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Get the current scroll bar visibility.\n    let hasVScroll = !this._vScrollBar.isHidden;\n    let hasHScroll = !this._hScrollBar.isHidden;\n\n    // Get the minimum sizes of the scroll bars.\n    let vsw = this._vScrollBarMinWidth;\n    let hsh = this._hScrollBarMinHeight;\n\n    // Get the page size as if no scroll bars are visible.\n    let apw = pw + (hasVScroll ? vsw : 0);\n    let aph = ph + (hasHScroll ? hsh : 0);\n\n    // Test whether scroll bars are needed for the adjusted size.\n    let needVScroll = aph < bh - 1;\n    let needHScroll = apw < bw - 1;\n\n    // Re-test the horizontal scroll if a vertical scroll is needed.\n    if (needVScroll && !needHScroll) {\n      needHScroll = (apw - vsw) < bw - 1;\n    }\n\n    // Re-test the vertical scroll if a horizontal scroll is needed.\n    if (needHScroll && !needVScroll) {\n      needVScroll = (aph - hsh) < bh - 1;\n    }\n\n    // If the visibility changes, immediately refit the grid.\n    if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {\n      this._vScrollBar.setHidden(!needVScroll);\n      this._hScrollBar.setHidden(!needHScroll);\n      this._scrollCorner.setHidden(!needVScroll || !needHScroll);\n      MessageLoop.sendMessage(this, Widget.Msg.FitRequest);\n    }\n\n    // Update the scroll bar limits.\n    this._vScrollBar.maximum = this.maxScrollY;\n    this._vScrollBar.page = this.pageHeight;\n    this._hScrollBar.maximum = this.maxScrollX;\n    this._hScrollBar.page = this.pageWidth;\n\n    // Re-clamp the scroll position.\n    this._scrollTo(this._scrollX, this._scrollY);\n  }\n\n  /**\n   * Sync the viewport to the given scroll position.\n   *\n   * #### Notes\n   * This schedules a full repaint and syncs the scroll state.\n   */\n  private _syncViewport(): void {\n    this.repaintContent();\n    this.repaintOverlay();\n    this._syncScrollState();\n  }\n\n  /**\n   * Process a message sent to the viewport\n   */\n  private _processViewportMessage(msg: Message): void {\n    switch (msg.type) {\n    case 'resize':\n      this._onViewportResize(msg as Widget.ResizeMessage);\n      break;\n    case 'scroll-request':\n      this._onViewportScrollRequest(msg);\n      break;\n    case 'paint-request':\n      this._onViewportPaintRequest(msg as Private.PaintRequest);\n      break;\n    case 'overlay-paint-request':\n      this._onViewportOverlayPaintRequest(msg);\n      break;\n    case 'row-resize-request':\n      this._onViewportRowResizeRequest(msg as Private.RowResizeRequest);\n      break;\n    case 'column-resize-request':\n      this._onViewportColumnResizeRequest(msg as Private.ColumnResizeRequest);\n      break;\n    default:\n      break;\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'resize'` message.\n   */\n  private _onViewportResize(msg: Widget.ResizeMessage): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Unpack the message data.\n    let { width, height } = msg;\n\n    // Measure the viewport node if the dimensions are unknown.\n    if (width === -1) {\n      width = this._viewport.node.offsetWidth;\n    }\n    if (height === -1) {\n      height = this._viewport.node.offsetHeight;\n    }\n\n    // Round the dimensions to the nearest pixel.\n    width = Math.round(width);\n    height = Math.round(height);\n\n    // Get the current size of the viewport.\n    let oldWidth = this._viewportWidth;\n    let oldHeight = this._viewportHeight;\n\n    // Updated internal viewport size.\n    this._viewportWidth = width;\n    this._viewportHeight = height;\n\n    // Resize the canvas if needed.\n    this._resizeCanvasIfNeeded(width, height);\n\n    // Bail early if there is nothing to paint.\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    // Paint the whole grid if the old size was zero.\n    if (oldWidth === 0 || oldHeight === 0) {\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Paint the right edge as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let bx = this._columnSections.offsetOf(this._columnSections.count - 1);\n      let x = Math.min(this.headerWidth + bx, oldWidth);\n      this.paintContent(x, 0, width - x, height);\n    } else if (width > oldWidth) {\n      this.paintContent(oldWidth, 0, width - oldWidth, height);\n    }\n\n    // Paint the bottom edge as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let by = this._rowSections.offsetOf(this._rowSections.count - 1);\n      let y = Math.min(this.headerHeight + by, oldHeight);\n      this.paintContent(0, y, width, height - y);\n    } else if (height > oldHeight) {\n      this.paintContent(0, oldHeight, width, height - oldHeight);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'scroll-request'` message.\n   */\n  private _onViewportScrollRequest(msg: Message): void {\n    this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'paint-request'` message.\n   */\n  private _onViewportPaintRequest(msg: Private.PaintRequest): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Set up the paint limits.\n    let xMin = 0;\n    let yMin = 0;\n    let xMax = this._viewportWidth - 1;\n    let yMax = this._viewportHeight - 1;\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch the header dimensions.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the section lists.\n    let rs = this._rowSections;\n    let cs = this._columnSections;\n    let rhs = this._rowHeaderSections;\n    let chs = this._columnHeaderSections;\n\n    // Unpack the message data.\n    let { region, r1, c1, r2, c2 } = msg;\n\n    // Set up the paint variables.\n    let x1: number;\n    let y1: number;\n    let x2: number;\n    let y2: number;\n\n    // Fill the paint variables based on the paint region.\n    switch (region) {\n    case 'all':\n      x1 = xMin;\n      y1 = yMin;\n      x2 = xMax;\n      y2 = yMax;\n      break;\n    case 'body':\n      r1 = Math.max(0, Math.min(r1, rs.count));\n      c1 = Math.max(0, Math.min(c1, cs.count));\n      r2 = Math.max(0, Math.min(r2, rs.count));\n      c2 = Math.max(0, Math.min(c2, cs.count));\n      x1 = cs.offsetOf(c1) - sx + hw;\n      y1 = rs.offsetOf(r1) - sy + hh;\n      x2 = cs.extentOf(c2) - sx + hw;\n      y2 = rs.extentOf(r2) - sy + hh;\n      break;\n    case 'row-header':\n      r1 = Math.max(0, Math.min(r1, rs.count));\n      c1 = Math.max(0, Math.min(c1, rhs.count));\n      r2 = Math.max(0, Math.min(r2, rs.count));\n      c2 = Math.max(0, Math.min(c2, rhs.count));\n      x1 = rhs.offsetOf(c1);\n      y1 = rs.offsetOf(r1) - sy + hh;\n      x2 = rhs.extentOf(c2);\n      y2 = rs.extentOf(r2) - sy + hh;\n      break;\n    case 'column-header':\n      r1 = Math.max(0, Math.min(r1, chs.count));\n      c1 = Math.max(0, Math.min(c1, cs.count));\n      r2 = Math.max(0, Math.min(r2, chs.count));\n      c2 = Math.max(0, Math.min(c2, cs.count));\n      x1 = cs.offsetOf(c1) - sx + hw;\n      y1 = chs.offsetOf(r1);\n      x2 = cs.extentOf(c2) - sx + hw;\n      y2 = chs.extentOf(r2);\n      break;\n    case 'corner-header':\n      r1 = Math.max(0, Math.min(r1, chs.count));\n      c1 = Math.max(0, Math.min(c1, rhs.count));\n      r2 = Math.max(0, Math.min(r2, chs.count));\n      c2 = Math.max(0, Math.min(c2, rhs.count));\n      x1 = rhs.offsetOf(c1);\n      y1 = chs.offsetOf(r1);\n      x2 = rhs.extentOf(c2);\n      y2 = chs.extentOf(r2);\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Bail early if the dirty rect is outside the bounds.\n    if (x2 < xMin || y2 < yMin || x1 > xMax || y1 > yMax) {\n      return;\n    }\n\n    // Clamp the dirty rect to the paint bounds.\n    x1 = Math.max(xMin, Math.min(x1, xMax));\n    y1 = Math.max(yMin, Math.min(y1, yMax));\n    x2 = Math.max(xMin, Math.min(x2, xMax));\n    y2 = Math.max(yMin, Math.min(y2, yMax));\n\n    // Paint the content of the dirty rect.\n    this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n  }\n\n  /**\n   * A message hook invoked on a viewport `'overlay-paint-request'` message.\n   */\n  private _onViewportOverlayPaintRequest(msg: Message): void {\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      return;\n    }\n\n    // Bail early if the viewport has zero area.\n    if (this._viewportWidth === 0 || this._viewportHeight === 0) {\n      return;\n    }\n\n    // Paint the content of the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * A message hook invoked on a viewport `'row-resize-request'` message.\n   */\n  private _onViewportRowResizeRequest(msg: Private.RowResizeRequest): void {\n    if (msg.region === 'body') {\n      this._resizeRow(msg.index, msg.size);\n    } else {\n      this._resizeColumnHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * A message hook invoked on a viewport `'column-resize-request'` message.\n   */\n  private _onViewportColumnResizeRequest(msg: Private.ColumnResizeRequest): void {\n    if (msg.region === 'body') {\n      this._resizeColumn(msg.index, msg.size);\n    } else {\n      this._resizeRowHeader(msg.index, msg.size);\n    }\n  }\n\n  /**\n   * Handle the `thumbMoved` signal from a scroll bar.\n   */\n  private _onThumbMoved(sender: ScrollBar): void {\n    MessageLoop.postMessage(this._viewport, Private.ScrollRequest);\n  }\n\n  /**\n   * Handle the `pageRequested` signal from a scroll bar.\n   */\n  private _onPageRequested(sender: ScrollBar, dir: 'decrement' | 'increment'): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByPage(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByPage(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * Handle the `stepRequested` signal from a scroll bar.\n   */\n  private _onStepRequested(sender: ScrollBar, dir: 'decrement' | 'increment'): void {\n    if (sender === this._vScrollBar) {\n      this.scrollByStep(dir === 'decrement' ? 'up' : 'down');\n    } else {\n      this.scrollByStep(dir === 'decrement' ? 'left' : 'right');\n    }\n  }\n\n  /**\n   * A signal handler for the data model `changed` signal.\n   */\n  private _onDataModelChanged(sender: DataModel, args: DataModel.ChangedArgs): void {\n    switch (args.type) {\n    case 'rows-inserted':\n      this._onRowsInserted(args);\n      break;\n    case 'columns-inserted':\n      this._onColumnsInserted(args);\n      break;\n    case 'rows-removed':\n      this._onRowsRemoved(args);\n      break;\n    case 'columns-removed':\n      this._onColumnsRemoved(args);\n      break;\n    case 'rows-moved':\n      this._onRowsMoved(args);\n      break;\n    case 'columns-moved':\n      this._onColumnsMoved(args);\n      break;\n    case 'cells-changed':\n      this._onCellsChanged(args);\n      break;\n    case 'model-reset':\n      this._onModelReset(args);\n      break;\n    default:\n      throw 'unreachable';\n    }\n  }\n\n  /**\n   * A signal handler for the selection model `changed` signal.\n   */\n  private _onSelectionsChanged(sender: SelectionModel): void {\n    this.repaintOverlay();\n  }\n\n  /**\n   * Handle rows being inserted in the data model.\n   */\n  private _onRowsInserted(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.insert(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being inserted into the data model.\n   */\n  private _onColumnsInserted(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to insert.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Insert the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.insert(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.insert(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows being removed from the data model.\n   */\n  private _onRowsRemoved(args: DataModel.RowsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollY === this.maxScrollY && this.maxScrollY > 0) {\n      list.remove(index, span);\n      this._scrollY = this.maxScrollY;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns being removed from the data model.\n   */\n  private _onColumnsRemoved(args: DataModel.ColumnsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span } = args;\n\n    // Bail early if there are no sections to remove.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail if the index or is invalid\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Remove the span, maintaining the scroll position as needed.\n    if (this._scrollX === this.maxScrollX && this.maxScrollX > 0) {\n      list.remove(index, span);\n      this._scrollX = this.maxScrollX;\n    } else {\n      list.remove(index, span);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle rows moving in the data model.\n   */\n  private _onRowsMoved(args: DataModel.RowsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._rowSections;\n    } else {\n      list = this._columnHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Compute the first affected index.\n    let r1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let r2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this.repaintRegion('body', r1, 0, r2, Infinity);\n      this.repaintRegion('row-header', r1, 0, r2, Infinity);\n    } else {\n      this.repaintRegion('column-header', r1, 0, r2, Infinity);\n      this.repaintRegion('corner-header', r1, 0, r2, Infinity);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle columns moving in the data model.\n   */\n  private _onColumnsMoved(args: DataModel.ColumnsMovedArgs): void {\n    // Unpack the arg data.\n    let { region, index, span, destination } = args;\n\n    // Bail early if there are no sections to move.\n    if (span <= 0) {\n      return;\n    }\n\n    // Look up the relevant section list.\n    let list: SectionList;\n    if (region === 'body') {\n      list = this._columnSections;\n    } else {\n      list = this._rowHeaderSections;\n    }\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Clamp the move span to the limit.\n    span = Math.min(span, list.count - index);\n\n    // Clamp the destination index to the limit.\n    destination = Math.min(Math.max(0, destination), list.count - span);\n\n    // Bail early if there is no effective move.\n    if (index === destination) {\n      return;\n    }\n\n    // Move the sections in the list.\n    list.move(index, span, destination);\n\n    // Compute the first affected index.\n    let c1 = Math.min(index, destination);\n\n    // Compute the last affected index.\n    let c2 = Math.max(index + span - 1, destination + span - 1);\n\n    // Schedule a repaint of the dirty cells.\n    if (region === 'body') {\n      this.repaintRegion('body', 0, c1, Infinity, c2);\n      this.repaintRegion('column-header', 0, c1, Infinity, c2);\n    } else {\n      this.repaintRegion('row-header', 0, c1, Infinity, c2);\n      this.repaintRegion('corner-header', 0, c1, Infinity, c2);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * Handle cells changing in the data model.\n   */\n  private _onCellsChanged(args: DataModel.CellsChangedArgs): void {\n    // Unpack the arg data.\n    let { region, row, column, rowSpan, columnSpan } = args;\n\n    // Bail early if there are no cells to modify.\n    if (rowSpan <= 0 && columnSpan <= 0) {\n      return;\n    }\n\n    // Compute the changed cell bounds.\n    let r1 = row;\n    let c1 = column;\n    let r2 = r1 + rowSpan - 1;\n    let c2 = c1 + columnSpan - 1;\n\n    // Schedule a repaint of the cell content.\n    this.repaintRegion(region, r1, c1, r2, c2);\n  }\n\n  /**\n   * Handle a full data model reset.\n   */\n  private _onModelReset(args: DataModel.ModelResetArgs): void {\n    // Look up the various current section counts.\n    let nr = this._rowSections.count;\n    let nc = this._columnSections.count;\n    let nrh = this._rowHeaderSections.count;\n    let nch = this._columnHeaderSections.count;\n\n    // Compute the delta count for each region.\n    let dr = this._dataModel!.rowCount('body') - nr;\n    let dc = this._dataModel!.columnCount('body') - nc;\n    let drh = this._dataModel!.columnCount('row-header') - nrh;\n    let dch = this._dataModel!.rowCount('column-header') - nch;\n\n    // Update the row sections, if needed.\n    if (dr > 0) {\n      this._rowSections.insert(nr, dr);\n    } else if (dr < 0) {\n      this._rowSections.remove(nr + dr, -dr);\n    }\n\n    // Update the column sections, if needed.\n    if (dc > 0) {\n      this._columnSections.insert(nc, dc);\n    } else if (dc < 0) {\n      this._columnSections.remove(nc + dc, -dc);\n    }\n\n    // Update the row header sections, if needed.\n    if (drh > 0) {\n      this._rowHeaderSections.insert(nrh, drh);\n    } else if (drh < 0) {\n      this._rowHeaderSections.remove(nrh + drh, -drh);\n    }\n\n    // Update the column header sections, if needed.\n    if (dch > 0) {\n      this._columnHeaderSections.insert(nch, dch);\n    } else if (dch < 0) {\n      this._columnHeaderSections.remove(nch + dch, -dch);\n    }\n\n    // Sync the viewport.\n    this._syncViewport();\n  }\n\n  /**\n   * A signal handler for the renderer map `changed` signal.\n   */\n  private _onRenderersChanged(): void {\n    this.repaintContent();\n  }\n\n  /**\n   * Handle the `'keydown'` event for the data grid.\n   */\n  private _evtKeyDown(event: KeyboardEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._keyHandler) {\n      this._keyHandler.onKeyDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousedown'` event for the data grid.\n   */\n  private _evtMouseDown(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Activate the grid.\n    this.activate();\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Add the extra document listeners.\n    document.addEventListener('keydown', this, true);\n    document.addEventListener('mouseup', this, true);\n    document.addEventListener('mousedown', this, true);\n    document.addEventListener('mousemove', this, true);\n    document.addEventListener('contextmenu', this, true);\n\n    // Flip the mousedown flag.\n    this._mousedown = true;\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDown(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mousemove'` event for the data grid.\n   */\n  private _evtMouseMove(event: MouseEvent): void {\n    // Stop the event propagation if the mouse is down.\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    // Bail if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Dispatch to the mouse handler.\n    if (this._mousedown) {\n      this._mouseHandler.onMouseMove(this, event);\n    } else {\n      this._mouseHandler.onMouseHover(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'mouseup'` event for the data grid.\n   */\n  private _evtMouseUp(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseUp(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'dblclick'` event for the data grid.\n   */\n  private _evtMouseDoubleClick(event: MouseEvent): void {\n    // Ignore everything except the left mouse button.\n    if (event.button !== 0) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.onMouseDoubleClick(this, event);\n    }\n\n    // Release the mouse.\n    this._releaseMouse();\n  }\n\n  /**\n   * Handle the `'mouseleave'` event for the data grid.\n   */\n  private _evtMouseLeave(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onMouseLeave(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'contextmenu'` event for the data grid.\n   */\n  private _evtContextMenu(event: MouseEvent): void {\n    if (this._mousedown) {\n      event.preventDefault();\n      event.stopPropagation();\n    } else if (this._mouseHandler) {\n      this._mouseHandler.onContextMenu(this, event);\n    }\n  }\n\n  /**\n   * Handle the `'wheel'` event for the data grid.\n   */\n  private _evtWheel(event: WheelEvent): void {\n    // Ignore the event if `accel` is held.\n    if (Platform.accelKey(event)) {\n      return;\n    }\n\n    // Bail early if there is no mouse handler.\n    if (!this._mouseHandler) {\n      return;\n    }\n\n    // Stop the event propagation.\n    event.preventDefault();\n    event.stopPropagation();\n\n    // Dispatch to the mouse handler.\n    this._mouseHandler.onWheel(this, event);\n  }\n\n  /**\n   * Release the mouse grab.\n   */\n  private _releaseMouse(): void {\n    // Clear the mousedown flag.\n    this._mousedown = false;\n\n    // Relase the mouse handler.\n    if (this._mouseHandler) {\n      this._mouseHandler.release();\n    }\n\n    // Remove the document listeners.\n    document.removeEventListener('keydown', this, true);\n    document.removeEventListener('mouseup', this, true);\n    document.removeEventListener('mousedown', this, true);\n    document.removeEventListener('mousemove', this, true);\n    document.removeEventListener('contextmenu', this, true);\n  }\n\n  /**\n   * Refresh the dpi ratio.\n   */\n  private _refreshDPI(): void {\n    // Get the best integral value for the dpi ratio.\n    let dpiRatio = Math.ceil(window.devicePixelRatio);\n\n    // Bail early if the computed dpi ratio has not changed.\n    if (this._dpiRatio === dpiRatio) {\n      return;\n    }\n\n    // Update the internal dpi ratio.\n    this._dpiRatio = dpiRatio;\n\n    // Schedule a repaint of the content.\n    this.repaintContent();\n\n    // Schedule a repaint of the overlay.\n    this.repaintOverlay();\n\n    // Update the canvas size for the new dpi ratio.\n    this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);\n\n    // Ensure the canvas style is scaled for the new ratio.\n    this._canvas.style.width = `${this._canvas.width / this._dpiRatio}px`;\n    this._canvas.style.height = `${this._canvas.height / this._dpiRatio}px`;\n\n    // Ensure the overlay style is scaled for the new ratio.\n    this._overlay.style.width = `${this._overlay.width / this._dpiRatio}px`;\n    this._overlay.style.height = `${this._overlay.height / this._dpiRatio}px`;\n  }\n\n  /**\n   * Resize a row section immediately.\n   */\n  private _resizeRow(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the column header height.\n    let hh = this.headerHeight;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hh - this._scrollY;\n\n    // Bail early if there is nothing to paint.\n    if (hh >= vh || offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hh) {\n      this._scrollY += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hh, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, pos, vw, vh - pos);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the X blit dimensions.\n    let sx = 0;\n    let sw = vw;\n    let dx = 0;\n\n    // Compute the Y blit dimensions.\n    let sy: number;\n    let sh: number;\n    let dy: number;\n    if (offset + newSize <= hh) {\n      sy = hh - delta;\n      sh = vh - sy;\n      dy = hh;\n    } else {\n      sy = offset + oldSize;\n      sh = vh - sy;\n      dy = sy + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hh) {\n      this.paintContent(0, pos, vw, offset + newSize - pos);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = hh + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column section immediately.\n   */\n  private _resizeColumn(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the row header width.\n    let hw = this.headerWidth;\n\n    // Compute the viewport offset of the section.\n    let offset = list.offsetOf(index) + hw - this._scrollX;\n\n    // Bail early if there is nothing to paint.\n    if (hw >= vw || offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Update the scroll position if the section is not visible.\n    if (offset + oldSize <= hw) {\n      this._scrollX += delta;\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the paint origin of the section.\n    let pos = Math.max(hw, offset);\n\n    // Paint from the section onward if it spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(pos, 0, vw - pos, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the Y blit dimensions.\n    let sy = 0;\n    let sh = vh;\n    let dy = 0;\n\n    // Compute the X blit dimensions.\n    let sx: number;\n    let sw: number;\n    let dx: number;\n    if (offset + newSize <= hw) {\n      sx = hw - delta;\n      sw = vw - sx;\n      dx = hw;\n    } else {\n      sx = offset + oldSize;\n      sw = vw - sx;\n      dx = sx + delta;\n    }\n\n    // Blit the valid content to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the section if needed.\n    if (newSize > 0 && offset + newSize > hw) {\n      this.paintContent(pos, 0, offset + newSize - pos, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = hw + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a row header section immediately.\n   */\n  private _resizeRowHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._rowHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vw) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vw || offset + newSize >= vw) {\n      this.paintContent(offset, 0, vw - offset, vh);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = offset + oldSize;\n    let sy = 0;\n    let sw = vw - sx;\n    let sh = vh;\n    let dx = sx + delta;\n    let dy = 0;\n\n    // Blit the valid contents to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(offset, 0, newSize, vh);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastColumn && this.pageWidth > this.bodyWidth) {\n      let c = this._columnSections.count - 1;\n      let x = this.headerWidth + this._columnSections.offsetOf(c);\n      this.paintContent(x, 0, vw - x, vh);\n    } else if (delta < 0) {\n      this.paintContent(vw + delta, 0, -delta, vh);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Resize a column header section immediately.\n   */\n  private _resizeColumnHeader(index: number, size: number): void {\n    // Look up the target section list.\n    let list = this._columnHeaderSections;\n\n    // Bail early if the index is out of range.\n    if (index < 0 || index >= list.count) {\n      return;\n    }\n\n    // Look up the old size of the section.\n    let oldSize = list.sizeOf(index);\n\n    // Normalize the new size of the section.\n    let newSize = list.clampSize(size);\n\n    // Bail early if the size does not change.\n    if (oldSize === newSize) {\n      return;\n    }\n\n    // Resize the section in the list.\n    list.resize(index, newSize);\n\n    // Get the current size of the viewport.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // If there is nothing to paint, sync the scroll state.\n    if (!this._viewport.isVisible || vw === 0 || vh === 0) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Compute the size delta.\n    let delta = newSize - oldSize;\n\n    // Look up the offset of the section.\n    let offset = list.offsetOf(index);\n\n    // Bail early if the section is fully outside the viewport.\n    if (offset >= vh) {\n      this._syncScrollState();\n      return;\n    }\n\n    // Paint the entire tail if the section spans the viewport.\n    if (offset + oldSize >= vh || offset + newSize >= vh) {\n      this.paintContent(0, offset, vw, vh - offset);\n      this._paintOverlay();\n      this._syncScrollState();\n      return;\n    }\n\n    // Compute the blit content dimensions.\n    let sx = 0;\n    let sy = offset + oldSize;\n    let sw = vw;\n    let sh = vh - sy;\n    let dx = 0;\n    let dy = sy + delta;\n\n    // Blit the valid contents to the destination.\n    this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);\n\n    // Repaint the header section if needed.\n    if (newSize > 0) {\n      this.paintContent(0, offset, vw, newSize);\n    }\n\n    // Paint the trailing space as needed.\n    if (this._stretchLastRow && this.pageHeight > this.bodyHeight) {\n      let r = this._rowSections.count - 1;\n      let y = this.headerHeight + this._rowSections.offsetOf(r);\n      this.paintContent(0, y, vw, vh - y);\n    } else if (delta < 0) {\n      this.paintContent(0, vh + delta, vw, -delta);\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n\n    // Sync the scroll state after painting.\n    this._syncScrollState();\n  }\n\n  /**\n   * Scroll immediately to the specified offset position.\n   */\n  private _scrollTo(x: number, y: number): void {\n    // Floor and clamp the position to the allowable range.\n    x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));\n    y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));\n\n    // Synchronize the scroll bar values.\n    this._hScrollBar.value = x;\n    this._vScrollBar.value = y;\n\n    // Compute the delta scroll amount.\n    let dx = x - this._scrollX;\n    let dy = y - this._scrollY;\n\n    // Bail early if there is no effective scroll.\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n\n    // Bail early if the viewport is not visible.\n    if (!this._viewport.isVisible) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the current size of the viewport.\n    let width = this._viewportWidth;\n    let height = this._viewportHeight;\n\n    // Bail early if the viewport is empty.\n    if (width === 0 || height === 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Get the visible content dimensions.\n    let contentWidth = width - contentX;\n    let contentHeight = height - contentY;\n\n    // Bail early if there is no content to draw.\n    if (contentWidth <= 0 && contentHeight <= 0) {\n      this._scrollX = x;\n      this._scrollY = y;\n      return;\n    }\n\n    // Compute the area which needs painting for the `dx` scroll.\n    let dxArea = 0;\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        dxArea = contentWidth * height;\n      } else {\n        dxArea = Math.abs(dx) * height;\n      }\n    }\n\n    // Compute the area which needs painting for the `dy` scroll.\n    let dyArea = 0;\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        dyArea = width * contentHeight;\n      } else {\n        dyArea = width * Math.abs(dy);\n      }\n    }\n\n    // If the area sum is larger than the total, paint everything.\n    if ((dxArea + dyArea) >= (width * height)) {\n      this._scrollX = x;\n      this._scrollY = y;\n      this.paintContent(0, 0, width, height);\n      this._paintOverlay();\n      return;\n    }\n\n    // Update the internal Y scroll position.\n    this._scrollY = y;\n\n    // Scroll the Y axis if needed. If the scroll distance exceeds\n    // the visible height, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dy !== 0 && contentHeight > 0) {\n      if (Math.abs(dy) >= contentHeight) {\n        this.paintContent(0, contentY, width, contentHeight);\n      } else {\n        let x = 0;\n        let y = dy < 0 ? contentY : contentY + dy;\n        let w = width;\n        let h = contentHeight - Math.abs(dy);\n        this._blitContent(this._canvas, x, y, w, h, x, y - dy);\n        this.paintContent(0, dy < 0 ? contentY : height - dy, width, Math.abs(dy));\n      }\n    }\n\n    // Update the internal X scroll position.\n    this._scrollX = x;\n\n    // Scroll the X axis if needed. If the scroll distance exceeds\n    // the visible width, paint everything. Otherwise, blit the\n    // valid content and paint the dirty region.\n    if (dx !== 0 && contentWidth > 0) {\n      if (Math.abs(dx) >= contentWidth) {\n        this.paintContent(contentX, 0, contentWidth, height);\n      } else {\n        let x = dx < 0 ? contentX : contentX + dx;\n        let y = 0;\n        let w = contentWidth - Math.abs(dx);\n        let h = height;\n        this._blitContent(this._canvas, x, y, w, h, x - dx, y);\n        this.paintContent(dx < 0 ? contentX : width - dx, 0, Math.abs(dx), height);\n      }\n    }\n\n    // Paint the overlay.\n    this._paintOverlay();\n  }\n\n  /**\n   * Blit content into the on-screen grid canvas.\n   *\n   * The rect should be expressed in viewport coordinates.\n   *\n   * This automatically accounts for the dpi ratio.\n   */\n  private _blitContent(source: HTMLCanvasElement, x: number, y: number, w: number, h: number, dx: number, dy: number): void {\n    // Scale the blit coordinates by the dpi ratio.\n    x *= this._dpiRatio;\n    y *= this._dpiRatio;\n    w *= this._dpiRatio;\n    h *= this._dpiRatio;\n    dx *= this._dpiRatio;\n    dy *= this._dpiRatio;\n\n    // Save the current gc state.\n    this._canvasGC.save();\n\n    // Set the transform to the identity matrix.\n    this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);\n\n    // Draw the specified content.\n    this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);\n\n    // Restore the gc state.\n    this._canvasGC.restore();\n  }\n\n  /**\n   * Paint the grid content for the given dirty rect.\n   *\n   * The rect should be expressed in valid viewport coordinates.\n   *\n   * This is the primary paint entry point. The individual `_draw*`\n   * methods should not be invoked directly. This method dispatches\n   * to the drawing methods in the correct order.\n   */\n  protected paintContent(rx: number, ry: number, rw: number, rh: number): void {\n    // Scale the canvas and buffer GC for the dpi ratio.\n    this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n    this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the dirty rect of all content.\n    this._canvasGC.clearRect(rx, ry, rw, rh);\n\n    // Draw the void region.\n    this._drawVoidRegion(rx, ry, rw, rh);\n\n    // Draw the body region.\n    this._drawBodyRegion(rx, ry, rw, rh);\n\n    // Draw the row header region.\n    this._drawRowHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the column header region.\n    this._drawColumnHeaderRegion(rx, ry, rw, rh);\n\n    // Draw the corner header region.\n    this.drawCornerHeaderRegion(rx, ry, rw, rh);\n  }\n\n  /**\n   * Paint the overlay content for the entire grid.\n   *\n   * This is the primary overlay paint entry point. The individual\n   * `_draw*` methods should not be invoked directly. This method\n   * dispatches to the drawing methods in the correct order.\n   */\n  private _paintOverlay(): void {\n    // Scale the overlay GC for the dpi ratio.\n    this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);\n\n    // Clear the overlay of all content.\n    this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);\n\n    // Draw the body selections.\n    this._drawBodySelections();\n\n    // Draw the row header selections.\n    this._drawRowHeaderSelections();\n\n    // Draw the column header selections.\n    this._drawColumnHeaderSelections();\n\n    // Draw the cursor.\n    this._drawCursor();\n\n    // Draw the shadows.\n    this._drawShadows();\n  }\n\n  /**\n   * Draw the void region for the dirty rect.\n   */\n  private _drawVoidRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Look up the void color.\n    let color = this._style.voidColor;\n\n    // Bail if there is no void color.\n    if (!color) {\n      return;\n    }\n\n    // Fill the dirty rect with the void color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(rx, ry, rw, rh);\n  }\n\n  /**\n   * Draw the body region which intersects the dirty rect.\n   */\n  private _drawBodyRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this._columnSections.length - this._scrollX;\n    let contentH = this._rowSections.length - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let bw = this.bodyWidth;\n    let ph = this.pageHeight;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is streched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Adjust the geometry if the last column is streched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'body',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.backgroundColor);\n\n    // Draw the row background.\n    this._drawRowBackground(rgn, this._style.rowBackgroundColor);\n\n    // Draw the column background.\n    this._drawColumnBackground(rgn, this._style.columnBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.horizontalGridLineColor ||\n      this._style.gridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.verticalGridLineColor ||\n      this._style.gridLineColor\n    );\n  }\n\n  /**\n   * Draw the row header region which intersects the dirty rect.\n   */\n  private _drawRowHeaderRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.bodyHeight - this._scrollY;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = this.headerHeight;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = Math.max(ry, contentY);\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Fetch max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._rowHeaderSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._rowSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last row is stretched.\n    if (this._stretchLastRow && ph > bh && r2 === maxRow) {\n      let dh = this.pageHeight - this.bodyHeight;\n      rowSizes[rowSizes.length - 1] += dh;\n      height += dh;\n      y2 += dh;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'row-header',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.headerHorizontalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.headerVerticalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the column header region which intersects the dirty rect.\n   */\n  private _drawColumnHeaderRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this.bodyWidth - this._scrollX;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = this.headerWidth;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = Math.max(rx, contentX);\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);\n\n    // Fetch the max row and column.\n    let maxRow = this._columnHeaderSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = maxRow;\n    }\n    if (c2 < 0) {\n      c2 = maxColumn;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._columnSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Adjust the geometry if the last column is stretched.\n    if (this._stretchLastColumn && pw > bw && c2 === maxColumn) {\n      let dw = this.pageWidth - this.bodyWidth;\n      columnSizes[columnSizes.length - 1] += dw;\n      width += dw;\n      x2 += dw;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'column-header',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.headerHorizontalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.headerVerticalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the corner header region which intersects the dirty rect.\n   */\n  protected drawCornerHeaderRegion(rx: number, ry: number, rw: number, rh: number): void {\n    // Get the visible content dimensions.\n    let contentW = this.headerWidth;\n    let contentH = this.headerHeight;\n\n    // Bail if there is no content to draw.\n    if (contentW <= 0 || contentH <= 0) {\n      return;\n    }\n\n    // Get the visible content origin.\n    let contentX = 0;\n    let contentY = 0;\n\n    // Bail if the dirty rect does not intersect the content area.\n    if (rx + rw <= contentX) {\n      return;\n    }\n    if (ry + rh <= contentY) {\n      return;\n    }\n    if (rx >= contentX + contentW) {\n      return;\n    }\n    if (ry >= contentY + contentH) {\n      return;\n    }\n\n    // Get the upper and lower bounds of the dirty content area.\n    let x1 = rx;\n    let y1 = ry;\n    let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);\n    let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);\n\n    // Convert the dirty content bounds into cell bounds.\n    let r1 = this._columnHeaderSections.indexOf(y1);\n    let c1 = this._rowHeaderSections.indexOf(x1);\n    let r2 = this._columnHeaderSections.indexOf(y2);\n    let c2 = this._rowHeaderSections.indexOf(x2);\n\n    // Handle a dirty content area larger than the cell count.\n    if (r2 < 0) {\n      r2 = this._columnHeaderSections.count - 1;\n    }\n    if (c2 < 0) {\n      c2 = this._rowHeaderSections.count - 1;\n    }\n\n    // Convert the cell bounds back to visible coordinates.\n    let x = this._rowHeaderSections.offsetOf(c1);\n    let y = this._columnHeaderSections.offsetOf(r1);\n\n    // Set up the paint region size variables.\n    let width = 0;\n    let height = 0;\n\n    // Allocate the section sizes arrays.\n    let rowSizes = new Array<number>(r2 - r1 + 1);\n    let columnSizes = new Array<number>(c2 - c1 + 1);\n\n    // Get the row sizes for the region.\n    for (let j = r1; j <= r2; ++j) {\n      let size = this._columnHeaderSections.sizeOf(j);\n      rowSizes[j - r1] = size;\n      height += size;\n    }\n\n    // Get the column sizes for the region.\n    for (let i = c1; i <= c2; ++i) {\n      let size = this._rowHeaderSections.sizeOf(i);\n      columnSizes[i - c1] = size;\n      width += size;\n    }\n\n    // Create the paint region object.\n    let rgn: Private.PaintRegion = {\n      region: 'corner-header',\n      xMin: x1, yMin: y1,\n      xMax: x2, yMax: y2,\n      x, y, width, height,\n      row: r1, column: c1,\n      rowSizes, columnSizes\n    };\n\n    // Draw the background.\n    this._drawBackground(rgn, this._style.headerBackgroundColor);\n\n    // Draw the cell content for the paint region.\n    this._drawCells(rgn);\n\n    // Draw the horizontal grid lines.\n    this._drawHorizontalGridLines(rgn,\n      this._style.headerHorizontalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n\n    // Draw the vertical grid lines.\n    this._drawVerticalGridLines(rgn,\n      this._style.headerVerticalGridLineColor ||\n      this._style.headerGridLineColor\n    );\n  }\n\n  /**\n   * Draw the background for the given paint region.\n   */\n  private _drawBackground(rgn: Private.PaintRegion, color: string | undefined): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Unpack the region.\n    let { xMin, yMin, xMax, yMax } = rgn;\n\n    // Fill the region with the specified color.\n    this._canvasGC.fillStyle = color;\n    this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);\n  }\n\n  /**\n   * Draw the row background for the given paint region.\n   */\n  private _drawRowBackground(rgn: Private.PaintRegion, colorFn: ((i: number) => string) | undefined): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the X bounds for the row.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n    let x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);\n\n    // Draw the background for the rows in the region.\n    for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the row.\n      let color = colorFn(rgn.row + j);\n\n      // Fill the row with the background color if needed.\n      if (color) {\n        let y1 = Math.max(rgn.yMin, y);\n        let y2 = Math.min(y + size - 1, rgn.yMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n  }\n\n  /**\n   * Draw the column background for the given paint region.\n   */\n  private _drawColumnBackground(rgn: Private.PaintRegion, colorFn: ((i: number) => string) | undefined): void {\n    // Bail if there is no color function.\n    if (!colorFn) {\n      return;\n    }\n\n    // Compute the Y bounds for the column.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n\n    // Draw the background for the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Get the background color for the column.\n      let color = colorFn(rgn.column + i);\n\n      // Fill the column with the background color if needed.\n      if (color) {\n        let x1 = Math.max(rgn.xMin, x);\n        let x2 = Math.min(x + size - 1, rgn.xMax);\n        this._canvasGC.fillStyle = color;\n        this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n  }\n\n  /**\n   * Draw the cells for the given paint region.\n   */\n  private _drawCells(rgn: Private.PaintRegion): void {\n    // Bail if there is no data model.\n    if (!this._dataModel) {\n      return;\n    }\n\n    // Set up the cell config object for rendering.\n    let config = {\n      x: 0, y: 0, width: 0, height: 0,\n      region: rgn.region, row: 0, column: 0,\n      value: (null as any), metadata: DataModel.emptyMetadata\n    };\n\n    // Save the buffer gc before wrapping.\n    this._bufferGC.save();\n\n    // Wrap the buffer gc for painting the cells.\n    let gc = new GraphicsContext(this._bufferGC);\n\n    // Compute the actual Y bounds for the cell range.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);\n\n    // Loop over the columns in the region.\n    for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i < n; ++i) {\n      // Fetch the size of the column.\n      let width = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (width === 0) {\n        continue;\n      }\n\n      // Compute the column index.\n      let column = rgn.column + i;\n\n      // Update the config for the current column.\n      config.x = x;\n      config.width = width;\n      config.column = column;\n\n      // Clear the buffer rect for the column.\n      gc.clearRect(x, rgn.y, width, rgn.height);\n\n      // Save the GC state.\n      gc.save();\n\n      // Loop over the rows in the column.\n      for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j < n; ++j) {\n        // Fetch the size of the row.\n        let height = rgn.rowSizes[j];\n\n        // Skip zero sized rows.\n        if (height === 0) {\n          continue;\n        }\n\n        // Compute the row index.\n        let row = rgn.row + j;\n\n        // Get the value for the cell.\n        let value: any;\n        try {\n          value = this._dataModel.data(rgn.region, row, column);\n        } catch (err) {\n          value = undefined;\n          console.error(err);\n        }\n\n        // Get the metadata for the cell.\n        let metadata: DataModel.Metadata;\n        try {\n          metadata = this._dataModel.metadata(rgn.region, row, column);\n        } catch (err) {\n          metadata = DataModel.emptyMetadata;\n          console.error(err);\n        }\n\n        // Update the config for the current cell.\n        config.y = y;\n        config.height = height;\n        config.row = row;\n        config.value = value;\n        config.metadata = metadata;\n\n        // Get the renderer for the cell.\n        let renderer = this._cellRenderers.get(config);\n\n        // Save the GC state.\n        gc.save();\n\n        // Paint the cell into the off-screen buffer.\n        try {\n          renderer.paint(gc, config);\n        } catch (err) {\n          console.error(err);\n        }\n\n        // Restore the GC state.\n        gc.restore();\n\n        // Increment the running Y coordinate.\n        y += height;\n      }\n\n      // Restore the GC state.\n      gc.restore();\n\n      // Compute the actual X bounds for the column.\n      let x1 = Math.max(rgn.xMin, x);\n      let x2 = Math.min(x + width - 1, rgn.xMax);\n\n      // Blit the off-screen buffer column into the on-screen canvas.\n      //\n      // This is *much* faster than drawing directly into the on-screen\n      // canvas with a clip rect on the column. Managed column clipping\n      // is required to prevent cell renderers from needing to set up a\n      // clip rect for handling horizontal overflow text (slow!).\n      this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);\n\n      // Increment the running X coordinate.\n      x += width;\n    }\n\n    // Dispose of the wrapped gc.\n    gc.dispose();\n\n    // Restore the final buffer gc state.\n    this._bufferGC.restore();\n  }\n\n  /**\n   * Draw the horizontal grid lines for the given paint region.\n   */\n  private _drawHorizontalGridLines(rgn: Private.PaintRegion, color: string | undefined): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the X bounds for the horizontal lines.\n    let x1 = Math.max(rgn.xMin, rgn.x);\n    let x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);\n\n    // Begin the path for the grid lines.\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.rowSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastRow && ph > bh) {\n      if (rgn.row + n === this._rowSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the horizontal grid lines.\n    for (let y = rgn.y, j = 0; j < n; ++j) {\n      // Fetch the size of the row.\n      let size = rgn.rowSizes[j];\n\n      // Skip zero sized rows.\n      if (size === 0) {\n        continue;\n      }\n\n      // Compute the Y position of the line.\n      let pos = y + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.yMin && pos <= rgn.yMax) {\n        this._canvasGC.moveTo(x1, pos + 0.5);\n        this._canvasGC.lineTo(x2, pos + 0.5);\n      }\n\n      // Increment the running Y coordinate.\n      y += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the vertical grid lines for the given paint region.\n   */\n  private _drawVerticalGridLines(rgn: Private.PaintRegion, color: string | undefined): void {\n    // Bail if there is no color to draw.\n    if (!color) {\n      return;\n    }\n\n    // Compute the Y bounds for the vertical lines.\n    let y1 = Math.max(rgn.yMin, rgn.y);\n    let y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);\n\n    // Begin the path for the grid lines\n    this._canvasGC.beginPath();\n\n    // Set the line width for the grid lines.\n    this._canvasGC.lineWidth = 1;\n\n    // Fetch the geometry.\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n\n    // Fetch the number of grid lines to be drawn.\n    let n = rgn.columnSizes.length;\n\n    // Adjust the count down if the last line shouldn't be drawn.\n    if (this._stretchLastColumn && pw > bw) {\n      if (rgn.column + n === this._columnSections.count) {\n        n -= 1;\n      }\n    }\n\n    // Draw the vertical grid lines.\n    for (let x = rgn.x, i = 0; i < n; ++i) {\n      // Fetch the size of the column.\n      let size = rgn.columnSizes[i];\n\n      // Skip zero sized columns.\n      if (size === 0) {\n        continue;\n      }\n\n      // Compute the X position of the line.\n      let pos = x + size - 1;\n\n      // Draw the line if it's in range of the dirty rect.\n      if (pos >= rgn.xMin && pos <= rgn.xMax) {\n        this._canvasGC.moveTo(pos + 0.5, y1);\n        this._canvasGC.lineTo(pos + 0.5, y2);\n      }\n\n      // Increment the running X coordinate.\n      x += size;\n    }\n\n    // Stroke the lines with the specified color.\n    this._canvasGC.strokeStyle = color;\n    this._canvasGC.stroke();\n  }\n\n  /**\n   * Draw the body selections for the data grid.\n   */\n  private _drawBodySelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections.\n    if (!model || model.isEmpty) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.selectionFillColor;\n    let stroke = this._style.selectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the scroll geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Get the first visible cell of the grid.\n    let r1 = this._rowSections.indexOf(sy);\n    let c1 = this._columnSections.indexOf(sx);\n\n    // Bail early if there are no visible cells.\n    if (r1 < 0 || c1 < 0) {\n      return;\n    }\n\n    // Fetch the extra geometry.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Get the last visible cell of the grid.\n    let r2 = this._rowSections.indexOf(sy + ph);\n    let c2 = this._columnSections.indexOf(sx + pw);\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Clamp the last cell if the void space is visible.\n    r2 = r2 < 0 ? maxRow : r2;\n    c2 = c2 < 0 ? maxColumn : c2;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Iterate over the selections.\n    let it = model.selections();\n    let s: SelectionModel.Selection | undefined;\n    while ((s = it.next()) !== undefined) {\n      // Skip the section if it's not visible.\n      if (s.r1 < r1 && s.r2 < r1) {\n        continue;\n      }\n      if (s.r1 > r2 && s.r2 > r2) {\n        continue\n      }\n      if (s.c1 < c1 && s.c2 < c1) {\n        continue;\n      }\n      if (s.c1 > c2 && s.c2 > c2) {\n        continue\n      }\n\n      // Clamp the cell to the model bounds.\n      let sr1 = Math.max(0, Math.min(s.r1, maxRow));\n      let sc1 = Math.max(0, Math.min(s.c1, maxColumn));\n      let sr2 = Math.max(0, Math.min(s.r2, maxRow));\n      let sc2 = Math.max(0, Math.min(s.c2, maxColumn));\n\n      // Swap index order if needed.\n      let tmp: number;\n      if (sr1 > sr2) {\n        tmp = sr1;\n        sr1 = sr2;\n        sr2 = tmp;\n      }\n      if (sc1 > sc2) {\n        tmp = sc1;\n        sc1 = sc2;\n        sc2 = tmp;\n      }\n\n      // Convert to pixel coordinates.\n      let x1 = this._columnSections.offsetOf(sc1) - sx + hw;\n      let y1 = this._rowSections.offsetOf(sr1) - sy + hh;\n      let x2 = this._columnSections.extentOf(sc2) - sx + hw;\n      let y2 = this._rowSections.extentOf(sr2) - sy + hh;\n\n      // Adjust the trailing X coordinate for column stretch.\n      if (this._stretchLastColumn && pw > bw && sc2 === maxColumn) {\n        x2 = hw + pw - 1;\n      }\n\n      // Adjust the trailing Y coordinate for row stretch.\n      if (this._stretchLastRow && ph > bh && sr2 === maxRow) {\n        y2 = hh + ph - 1;\n      }\n\n      // Clamp the bounds to just outside of the clipping rect.\n      x1 = Math.max(hw - 1, x1);\n      y1 = Math.max(hh - 1, y1);\n      x2 = Math.min(hw + pw + 1, x2);\n      y2 = Math.min(hh + ph + 1, y2);\n\n      // Skip zero sized ranges.\n      if (x2 < x1 || y2 < y1) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n      }\n\n      // Stroke the rect if needed.\n      if (stroke) {\n        gc.strokeRect(x1 - .5, y1 - .5, x2 - x1 + 1, y2 - y1 + 1);\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the row header selections for the data grid.\n   */\n  private _drawRowHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire column.\n    if (!model || model.isEmpty || model.selectionMode == 'column') {\n      return;\n    }\n\n    // Bail early if the row headers are not visible.\n    if (this.headerWidth === 0 || this.pageHeight === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sy = this._scrollY;\n    let bh = this.bodyHeight;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let rs = this._rowSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(0, hh, hw, ph);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max row.\n    let maxRow = rs.count - 1;\n\n    // Fetch the visible rows.\n    let r1 = rs.indexOf(sy);\n    let r2 = rs.indexOf(sy + ph - 1);\n    r2 = r2 < 0 ? maxRow : r2;\n\n    // Iterate over the visible rows.\n    for (let j = r1; j <= r2; ++j) {\n      // Skip rows which aren't selected.\n      if (!model.isRowSelected(j)) {\n        continue;\n      }\n\n      // Get the dimensions of the row.\n      let y = rs.offsetOf(j) - sy + hh;\n      let h = rs.sizeOf(j);\n\n      // Adjust the height for row stretch.\n      if (this._stretchLastRow && ph > bh && j === maxRow) {\n        h = hh + ph - y;\n      }\n\n      // Skip zero sized rows.\n      if (h === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(0, y, hw, h);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(hw - .5, y - 1);\n        gc.lineTo(hw - .5, y + h);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the column header selections for the data grid.\n   */\n  private _drawColumnHeaderSelections(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there are no selections or if the selectionMode is the entire row\n    if (!model || model.isEmpty || model.selectionMode == 'row') {\n      return;\n    }\n\n    // Bail early if the column headers are not visible.\n    if (this.headerHeight === 0 || this.pageWidth === 0) {\n      return;\n    }\n\n    // Fetch the selection colors.\n    let fill = this._style.headerSelectionFillColor;\n    let stroke = this._style.headerSelectionBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch common geometry.\n    let sx = this._scrollX;\n    let bw = this.bodyWidth;\n    let pw = this.pageWidth;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let cs = this._columnSections;\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the header clipping rect.\n    gc.beginPath();\n    gc.rect(hw, 0, pw, hh);\n    gc.clip();\n\n    // Set up the gc style.\n    if (fill) {\n      gc.fillStyle = fill;\n    }\n    if (stroke) {\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 1;\n    }\n\n    // Fetch the max column.\n    let maxCol = cs.count - 1;\n\n    // Fetch the visible columns.\n    let c1 = cs.indexOf(sx);\n    let c2 = cs.indexOf(sx + pw - 1);\n    c2 = c2 < 0 ? maxCol : c2;\n\n    // Iterate over the visible columns.\n    for (let i = c1; i <= c2; ++i) {\n      // Skip columns which aren't selected.\n      if (!model.isColumnSelected(i)) {\n        continue;\n      }\n\n      // Get the dimensions of the column.\n      let x = cs.offsetOf(i) - sx + hw;\n      let w = cs.sizeOf(i);\n\n      // Adjust the width for column stretch.\n      if (this._stretchLastColumn && pw > bw && i === maxCol) {\n        w = hw + pw - x;\n      }\n\n      // Skip zero sized columns.\n      if (w === 0) {\n        continue;\n      }\n\n      // Fill the rect if needed.\n      if (fill) {\n        gc.fillRect(x, 0, w, hh);\n      }\n\n      // Draw the border if needed.\n      if (stroke) {\n        gc.beginPath();\n        gc.moveTo(x - 1, hh - .5);\n        gc.lineTo(x + w, hh - .5);\n        gc.stroke();\n      }\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay cursor for the data grid.\n   */\n  private _drawCursor(): void {\n    // Fetch the selection model.\n    let model = this._selectionModel;\n\n    // Bail early if there is no cursor.\n    if (!model || model.isEmpty || model.selectionMode !== 'cell') {\n      return;\n    }\n\n    // Extract the style information.\n    let fill = this._style.cursorFillColor;\n    let stroke = this._style.cursorBorderColor;\n\n    // Bail early if there is nothing to draw.\n    if (!fill && !stroke) {\n      return;\n    }\n\n    // Fetch the cursor location.\n    let row = model.cursorRow;\n    let column = model.cursorColumn;\n\n    // Fetch the max row and column.\n    let maxRow = this._rowSections.count - 1;\n    let maxColumn = this._columnSections.count - 1;\n\n    // Bail early if the cursor is out of bounds.\n    if (row < 0 || row > maxRow) {\n      return;\n    }\n    if (column < 0 || column > maxColumn) {\n      return;\n    }\n\n    // Fetch geometry.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Get the cursor bounds in viewport coordinates.\n    let x1 = this._columnSections.offsetOf(column) - sx + hw;\n    let x2 = this._columnSections.extentOf(column) - sx + hw;\n    let y1 = this._rowSections.offsetOf(row) - sy + hh;\n    let y2 = this._rowSections.extentOf(row) - sy + hh;\n\n    // Adjust the trailing X coordinate for column stretch.\n    if (this._stretchLastColumn && pw > bw && column === maxColumn) {\n      x2 = vw - 1;\n    }\n\n    // Adjust the trailing Y coordinate for row stretch.\n    if (this._stretchLastRow && ph > bh && row === maxRow) {\n      y2 = vh - 1;\n    }\n\n    // Skip zero sized cursors.\n    if (x2 < x1 || y2 < y1) {\n      return;\n    }\n\n    // Bail early if the cursor is off the screen.\n    if ((x1 - 1) >= vw || (y1 - 1) >= vh || (x2 + 1) < hw || (y2 + 1) < hh) {\n      return;\n    }\n\n    // Fetch the overlay gc.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Set up the body clipping rect.\n    gc.beginPath();\n    gc.rect(hw, hh, pw, ph);\n    gc.clip();\n\n    // Clear any existing overlay content.\n    gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);\n\n    // Fill the cursor rect if needed.\n    if (fill) {\n      // Set up the fill style.\n      gc.fillStyle = fill;\n\n      // Fill the cursor rect.\n      gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1)\n    }\n\n    // Stroke the cursor border if needed.\n    if (stroke) {\n      // Set up the stroke style.\n      gc.strokeStyle = stroke;\n      gc.lineWidth = 2;\n\n      // Stroke the cursor rect.\n      gc.strokeRect(x1, y1, x2 - x1, y2 - y1);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  /**\n   * Draw the overlay shadows for the data grid.\n   */\n  private _drawShadows(): void {\n    // Fetch the scroll shadow from the style.\n    let shadow = this._style.scrollShadow;\n\n    // Bail early if there is no shadow to draw.\n    if (!shadow) {\n      return;\n    }\n\n    // Fetch the scroll position.\n    let sx = this._scrollX;\n    let sy = this._scrollY;\n\n    // Fetch maximum scroll position.\n    let sxMax = this.maxScrollX;\n    let syMax = this.maxScrollY;\n\n    // Fetch the header width and height.\n    let hw = this.headerWidth;\n    let hh = this.headerHeight;\n\n    // Fetch the page width and height.\n    let pw = this.pageWidth;\n    let ph = this.pageHeight;\n\n    // Fetch the viewport width and height.\n    let vw = this._viewportWidth;\n    let vh = this._viewportHeight;\n\n    // Fetch the body width and height.\n    let bw = this.bodyWidth;\n    let bh = this.bodyHeight;\n\n    // Adjust the body size for row and column stretch.\n    if (this._stretchLastRow && ph > bh) {\n      bh = ph;\n    }\n    if (this._stretchLastColumn && pw > bw) {\n      bw = pw;\n    }\n\n    // Fetch the gc object.\n    let gc = this._overlayGC;\n\n    // Save the gc state.\n    gc.save();\n\n    // Draw the column header shadow if needed.\n    if (sy > 0) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = hh;\n      let x1 = 0;\n      let y1 = y0 + shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = hh;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row header shadow if needed.\n    if (sx > 0) {\n      // Set up the gradient coordinates.\n      let x0 = hw;\n      let y0 = 0;\n      let x1 = x0 + shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = hw;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the column footer shadow if needed.\n    if (sy < syMax) {\n      // Set up the gradient coordinates.\n      let x0 = 0;\n      let y0 = vh;\n      let x1 = 0;\n      let y1 = vh - shadow.size;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = 0;\n      let y = vh - shadow.size;\n      let w = hw + Math.min(pw, bw - sx);\n      let h = shadow.size;\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Draw the row footer shadow if needed.\n    if (sx < sxMax) {\n      // Set up the gradient coordinates.\n      let x0 = vw;\n      let y0 = 0;\n      let x1 = vw - shadow.size;\n      let y1 = 0;\n\n      // Create the gradient object.\n      let grad = gc.createLinearGradient(x0, y0, x1, y1);\n\n      // Set the gradient stops.\n      grad.addColorStop(0, shadow.color1);\n      grad.addColorStop(0.5, shadow.color2);\n      grad.addColorStop(1, shadow.color3);\n\n      // Set up the rect coordinates.\n      let x = vw - shadow.size;\n      let y = 0;\n      let w = shadow.size;\n      let h = hh + Math.min(ph, bh - sy);\n\n      // Fill the shadow rect with the fill style.\n      gc.fillStyle = grad;\n      gc.fillRect(x, y, w, h);\n    }\n\n    // Restore the gc state.\n    gc.restore();\n  }\n\n  private _viewport: Widget;\n  private _vScrollBar: ScrollBar;\n  private _hScrollBar: ScrollBar;\n  private _scrollCorner: Widget;\n\n  private _scrollX = 0;\n  private _scrollY = 0;\n  private _viewportWidth = 0;\n  private _viewportHeight = 0;\n\n  private _mousedown = false;\n  private _keyHandler: DataGrid.IKeyHandler | null = null;\n  private _mouseHandler: DataGrid.IMouseHandler | null = null;\n\n  private _vScrollBarMinWidth = 0;\n  private _hScrollBarMinHeight = 0;\n  private _dpiRatio = Math.ceil(window.devicePixelRatio);\n\n  private _canvas: HTMLCanvasElement;\n  private _buffer: HTMLCanvasElement;\n  private _overlay: HTMLCanvasElement;\n  private _canvasGC: CanvasRenderingContext2D;\n  private _bufferGC: CanvasRenderingContext2D;\n  private _overlayGC: CanvasRenderingContext2D;\n\n  private _rowSections: SectionList;\n  private _columnSections: SectionList;\n  private _rowHeaderSections: SectionList;\n  private _columnHeaderSections: SectionList;\n\n  private _dataModel: DataModel | null = null;\n  private _selectionModel: SelectionModel | null = null;\n\n  private _stretchLastRow: boolean;\n  private _stretchLastColumn: boolean;\n\n  private _style: DataGrid.Style;\n  private _cellRenderers: RendererMap;\n  private _copyConfig: DataGrid.CopyConfig;\n  private _headerVisibility: DataGrid.HeaderVisibility;\n  private _editorController: ICellEditorController | null;\n  private _editingEnabled: boolean = false;\n}\n\n\n/**\n * The namespace for the `DataGrid` class statics.\n */\nexport\nnamespace DataGrid {\n  /**\n   * An object which defines the style for a data grid.\n   *\n   * #### Notes\n   * All style colors support the full CSS color syntax.\n   */\n  export\n  type Style = {\n    /**\n     * The void color for the data grid.\n     *\n     * This is the base fill color for the entire data grid.\n     */\n    readonly voidColor?: string;\n\n    /**\n     * The background color for the body cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly backgroundColor?: string;\n\n    /**\n     * A function which returns the background color for a row.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid rows.\n     */\n    readonly rowBackgroundColor?: (index: number) => string;\n\n    /**\n     * A function which returns the background color for a column.\n     *\n     * This color is layered on top of the `backgroundColor` and can\n     * be used to implement \"zebra striping\" of the grid columns.\n     */\n    readonly columnBackgroundColor?: (index: number) => string;\n\n    /**\n     * The color for the grid lines of the body cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly gridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly verticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the body cells.\n     *\n     * This overrides the `gridLineColor` option.\n     */\n    readonly horizontalGridLineColor?: string;\n\n    /**\n     * The background color for the header cells.\n     *\n     * This color is layered on top of the `voidColor`.\n     */\n    readonly headerBackgroundColor?: string;\n\n    /**\n     * The color for the grid lines of the header cells.\n     *\n     * The grid lines are draw on top of the cell contents.\n     */\n    readonly headerGridLineColor?: string;\n\n    /**\n     * The color for the vertical grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerVerticalGridLineColor?: string;\n\n    /**\n     * The color for the horizontal grid lines of the header cells.\n     *\n     * This overrides the `headerGridLineColor` option.\n     */\n    readonly headerHorizontalGridLineColor?: string;\n\n    /**\n     * The fill color for a selection.\n     */\n    readonly selectionFillColor?: string;\n\n    /**\n     * The border color for a selection.\n     */\n    readonly selectionBorderColor?: string;\n\n    /**\n     * The fill color for the cursor.\n     */\n    readonly cursorFillColor?: string;\n\n    /**\n     * The border color for the cursor.\n     */\n    readonly cursorBorderColor?: string;\n\n    /**\n     * The fill color for a header selection.\n     */\n    readonly headerSelectionFillColor?: string;\n\n    /**\n     * The border color for a header selection.\n     */\n    readonly headerSelectionBorderColor?: string;\n\n    /**\n     * The drop shadow effect when the grid is scrolled.\n     */\n    readonly scrollShadow?: {\n      /**\n       * The size of the shadow, in pixels.\n       */\n      readonly size: number;\n\n      /**\n       * The first color stop for the shadow.\n       */\n      readonly color1: string;\n\n      /**\n       * The second color stop for the shadow.\n       */\n      readonly color2: string;\n\n      /**\n       * The third color stop for the shadow.\n       */\n      readonly color3: string;\n    };\n  };\n\n  /**\n   * An object which defines the default sizes for a data grid.\n   */\n  export\n  type DefaultSizes = {\n    /**\n     * The default height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The default width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The default width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The default height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * An object which defines the minimum sizes for a data grid.\n   */\n  export\n  type MinimumSizes = {\n    /**\n     * The minimum height of a row.\n     */\n    readonly rowHeight: number;\n\n    /**\n     * The minimum width of a column.\n     */\n    readonly columnWidth: number;\n\n    /**\n     * The minimum width of a row header.\n     */\n    readonly rowHeaderWidth: number;\n\n    /**\n     * The minimum height of a column header.\n     */\n    readonly columnHeaderHeight: number;\n  };\n\n  /**\n   * A type alias for the supported header visibility modes.\n   */\n  export\n  type HeaderVisibility = 'all' | 'row' | 'column' | 'none';\n\n  /**\n   * A type alias for the arguments to a copy format function.\n   */\n  export\n  type CopyFormatArgs = {\n    /**\n     * The cell region for the value.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the value.\n     */\n    row: number;\n\n    /**\n     * The column index of the value.\n     */\n    column: number;\n\n    /**\n     * The value for the cell.\n     */\n    value: any;\n\n    /**\n     * The metadata for the cell.\n     */\n    metadata: DataModel.Metadata;\n  };\n\n  /**\n   * A type alias for a copy format function.\n   */\n  export\n  type CopyFormatFunc = (args: CopyFormatArgs) => string;\n\n  /**\n   * A type alias for the data grid copy config.\n   */\n  export\n  type CopyConfig = {\n    /**\n     * The separator to use between values.\n     */\n    readonly separator: string;\n\n    /**\n     * The headers to included in the copied output.\n     */\n    readonly headers: 'none' | 'row' | 'column' | 'all';\n\n    /**\n     * The function for formatting the data values.\n     */\n    readonly format: CopyFormatFunc;\n\n    /**\n     * The cell count threshold for a copy to be considered \"large\".\n     */\n    readonly warningThreshold: number;\n  };\n\n  /**\n   * An options object for initializing a data grid.\n   */\n  export\n  interface IOptions {\n    /**\n     * The style for the data grid.\n     *\n     * The default is `DataGrid.defaultStyle`.\n     */\n    style?: Style;\n\n    /**\n     * The default sizes for the data grid.\n     *\n     * The default is `DataGrid.defaultSizes`.\n     */\n    defaultSizes?: DefaultSizes;\n\n    /**\n     * The minimum sizes for the data grid.\n     *\n     * The default is `DataGrid.minimumSizes`.\n     */\n    minimumSizes?: MinimumSizes;\n\n    /**\n     * The header visibility for the data grid.\n     *\n     * The default is `'all'`.\n     */\n    headerVisibility?: HeaderVisibility;\n\n    /**\n     * The cell renderer map for the data grid.\n     *\n     * The default is an empty renderer map.\n     */\n    cellRenderers?: RendererMap;\n\n    /**\n     * The default cell renderer for the data grid.\n     *\n     * The default is a new `TextRenderer`.\n     */\n    defaultRenderer?: CellRenderer;\n\n    /**\n     * The copy configuration data for the grid.\n     *\n     * The default is `DataGrid.defaultCopyConfig`.\n     */\n    copyConfig?: CopyConfig;\n\n    /**\n     * Whether to stretch the last row of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastRow?: boolean;\n\n    /**\n     * Whether to stretch the last column of the grid.\n     *\n     * The default is `false`.\n     */\n    stretchLastColumn?: boolean;\n  }\n\n  /**\n   * An object which handles keydown events for the data grid.\n   */\n  export\n  interface IKeyHandler extends IDisposable {\n    /**\n     * Handle the key down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The keydown event of interest.\n     *\n     * #### Notes\n     * This will not be called if the mouse button is pressed.\n     */\n    onKeyDown(grid: DataGrid, event: KeyboardEvent): void;\n  }\n\n  /**\n   * An object which handles mouse events for the data grid.\n   */\n  export\n  interface IMouseHandler extends IDisposable {\n    /**\n     * Release any resources acquired during a mouse press.\n     *\n     * #### Notes\n     * This method is called when the mouse should be released\n     * independent of a mouseup event, such as an early detach.\n     */\n    release(): void;\n\n    /**\n     * Handle the mouse hover event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseHover(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse leave event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse hover event of interest.\n     */\n    onMouseLeave(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse down event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse down event of interest.\n     */\n    onMouseDown(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse move event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse move event of interest.\n     */\n    onMouseMove(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse up event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse up event of interest.\n     */\n    onMouseUp(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the mouse double click event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The mouse double click event of interest.\n     */\n    onMouseDoubleClick(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the context menu event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The context menu event of interest.\n     */\n    onContextMenu(grid: DataGrid, event: MouseEvent): void;\n\n    /**\n     * Handle the wheel event for the data grid.\n     *\n     * @param grid - The data grid of interest.\n     *\n     * @param event - The wheel event of interest.\n     */\n    onWheel(grid: DataGrid, event: WheelEvent): void;\n  }\n\n  /**\n   * An object which holds the result of a grid hit test.\n   */\n  export\n  type HitTestResult = {\n    /**\n     * The region of the data grid that was hit.\n     */\n    readonly region: DataModel.CellRegion | 'void';\n\n    /**\n     * The row index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly row: number;\n\n    /**\n     * The column index of the cell that was hit.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly column: number;\n\n    /**\n     * The X coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly x: number;\n\n    /**\n     * The Y coordinate of the mouse in cell coordinates.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly y: number;\n\n    /**\n     * The width of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly width: number;\n\n    /**\n     * The height of the cell.\n     *\n     * This is `-1` for the `void` region.\n     */\n    readonly height: number;\n  };\n\n  /**\n   * A generic format function for the copy handler.\n   *\n   * @param args - The format args for the function.\n   *\n   * @returns The string representation of the value.\n   *\n   * #### Notes\n   * This function uses `String()` to coerce a value to a string.\n   */\n  export\n  function copyFormatGeneric(args: CopyFormatArgs): string {\n    if (args.value === null || args.value === undefined) {\n      return '';\n    }\n    return String(args.value);\n  }\n\n  /**\n   * The default theme for a data grid.\n   */\n  export\n  const defaultStyle: Style = {\n    voidColor: '#F3F3F3',\n    backgroundColor: '#FFFFFF',\n    gridLineColor: 'rgba(20, 20, 20, 0.15)',\n    headerBackgroundColor: '#F3F3F3',\n    headerGridLineColor: 'rgba(20, 20, 20, 0.25)',\n    selectionFillColor: 'rgba(49, 119, 229, 0.2)',\n    selectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    cursorBorderColor: 'rgba(0, 107, 247, 1.0)',\n    headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',\n    headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',\n    scrollShadow: {\n      size: 10,\n      color1: 'rgba(0, 0, 0, 0.20)',\n      color2: 'rgba(0, 0, 0, 0.05)',\n      color3: 'rgba(0, 0, 0, 0.00)' }\n  };\n\n  /**\n   * The default sizes for a data grid.\n   */\n  export\n  const defaultSizes: DefaultSizes = {\n    rowHeight: 20,\n    columnWidth: 64,\n    rowHeaderWidth: 64,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default minimum sizes for a data grid.\n   */\n  export\n  const minimumSizes: MinimumSizes = {\n    rowHeight: 20,\n    columnWidth: 10,\n    rowHeaderWidth: 10,\n    columnHeaderHeight: 20\n  };\n\n  /**\n   * The default copy config for a data grid.\n   */\n  export\n  const defaultCopyConfig: CopyConfig = {\n    separator: '\\t',\n    format: copyFormatGeneric,\n    headers: 'none',\n    warningThreshold: 1e6\n  };\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * A singleton `scroll-request` conflatable message.\n   */\n  export\n  const ScrollRequest = new ConflatableMessage('scroll-request');\n\n  /**\n   * A singleton `overlay-paint-request` conflatable message.\n   */\n  export\n  const OverlayPaintRequest = new ConflatableMessage('overlay-paint-request');\n\n  /**\n   * Create a new zero-sized canvas element.\n   */\n  export\n  function createCanvas(): HTMLCanvasElement {\n    let canvas = document.createElement('canvas');\n    canvas.width = 0;\n    canvas.height = 0;\n    return canvas;\n  }\n\n  /**\n   * An object which represents a region to be painted.\n   */\n  export\n  type PaintRegion = {\n    /**\n     * The min X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMin: number;\n\n    /**\n     * The min Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMin: number;\n\n    /**\n     * The max X coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    xMax: number;\n\n    /**\n     * The max Y coordinate the of the dirty viewport rect.\n     *\n     * #### Notes\n     * The data grid must not draw outside of this boundary.\n     */\n    yMax: number;\n\n    /**\n     * The X coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    x: number;\n\n    /**\n     * The Y coordinate the of the region, in viewport coordinates.\n     *\n     * #### Notes\n     * This is aligned to the first cell boundary.\n     */\n    y: number;\n\n    /**\n     * The total width of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    width: number;\n\n    /**\n     * The total height of the region.\n     *\n     * #### Notes\n     * This is aligned to the cell boundaries.\n     */\n    height: number;\n\n    /**\n     * The cell region being painted.\n     */\n    region: DataModel.CellRegion;\n\n    /**\n     * The row index of the first cell in the region.\n     */\n    row: number;\n\n    /**\n     * The column index of the first cell in the region.\n     */\n    column: number;\n\n    /**\n     * The row sizes for the rows in the region.\n     */\n    rowSizes: number[];\n\n    /**\n     * The column sizes for the columns in the region.\n     */\n    columnSizes: number[];\n  };\n\n  /**\n   * A conflatable message which merges dirty paint regions.\n   */\n  export\n  class PaintRequest extends ConflatableMessage {\n    /**\n     * Construct a new paint request messages.\n     *\n     * @param region - The cell region for the paint.\n     *\n     * @param r1 - The top-left row of the dirty region.\n     *\n     * @param c1 - The top-left column of the dirty region.\n     *\n     * @param r2 - The bottom-right row of the dirty region.\n     *\n     * @param c2 - The bottom-right column of the dirty region.\n     */\n    constructor(region: DataModel.CellRegion | 'all', r1: number, c1: number, r2: number, c2: number) {\n      super('paint-request');\n      this._region = region;\n      this._r1 = r1;\n      this._c1 = c1;\n      this._r2 = r2;\n      this._c2 = c2;\n    }\n\n    /**\n     * The cell region for the paint.\n     */\n    get region(): DataModel.CellRegion | 'all' {\n      return this._region;\n    }\n\n    /**\n     * The top-left row of the dirty region.\n     */\n    get r1(): number {\n      return this._r1;\n    }\n\n    /**\n     * The top-left column of the dirty region.\n     */\n    get c1(): number {\n      return this._c1;\n    }\n\n    /**\n     * The bottom-right row of the dirty region.\n     */\n    get r2(): number {\n      return this._r2;\n    }\n\n    /**\n     * The bottom-right column of the dirty region.\n     */\n    get c2(): number {\n      return this._c2;\n    }\n\n    /**\n     * Conflate this message with another paint request.\n     */\n    conflate(other: PaintRequest): boolean {\n      // Bail early if the request is already painting everything.\n      if (this._region === 'all') {\n        return true;\n      }\n\n      // Any region can conflate with the `'all'` region.\n      if (other._region === 'all') {\n        this._region = 'all';\n        return true;\n      }\n\n      // Otherwise, do not conflate with a different region.\n      if (this._region !== other._region) {\n        return false;\n      }\n\n      // Conflate the region to the total boundary.\n      this._r1 = Math.min(this._r1, other._r1);\n      this._c1 = Math.min(this._c1, other._c1);\n      this._r2 = Math.max(this._r2, other._r2);\n      this._c2 = Math.max(this._c2, other._c2);\n      return true;\n    }\n\n    private _region: DataModel.CellRegion | 'all';\n    private _r1: number;\n    private _c1: number;\n    private _r2: number;\n    private _c2: number;\n  }\n\n  /**\n   * A conflatable message for resizing rows.\n   */\n  export\n  class RowResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new row resize request.\n     *\n     * @param region - The row region which holds the section.\n     *\n     * @param index - The index of row in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.RowRegion, index: number, size: number) {\n      super('row-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The row region which holds the section.\n     */\n    get region(): DataModel.RowRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the row in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another row resize request.\n     */\n    conflate(other: RowResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.RowRegion;\n    private _index: number;\n    private _size: number;\n  }\n\n  /**\n   * A conflatable message for resizing columns.\n   */\n  export\n  class ColumnResizeRequest extends ConflatableMessage {\n    /**\n     * Construct a new column resize request.\n     *\n     * @param region - The column region which holds the section.\n     *\n     * @param index - The index of column in the region.\n     *\n     * @param size - The target size of the section.\n     */\n    constructor(region: DataModel.ColumnRegion, index: number, size: number) {\n      super('column-resize-request');\n      this._region = region;\n      this._index = index;\n      this._size = size;\n    }\n\n    /**\n     * The column region which holds the section.\n     */\n    get region(): DataModel.ColumnRegion {\n      return this._region;\n    }\n\n    /**\n     * The index of the column in the region.\n     */\n    get index(): number {\n      return this._index;\n    }\n\n    /**\n     * The target size of the section.\n     */\n    get size(): number {\n      return this._size;\n    }\n\n    /**\n     * Conflate this message with another column resize request.\n     */\n    conflate(other: ColumnResizeRequest): boolean {\n      if (this._region !== other._region || this._index !== other._index) {\n        return false;\n      }\n      this._size = other._size;\n      return true;\n    }\n\n    private _region: DataModel.ColumnRegion;\n    private _index: number;\n    private _size: number;\n  }\n}\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2019, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport {\n  ReadonlyJSONObject\n} from '@lumino/coreutils';\n\nimport {\n  DataModel\n} from './datamodel';\n\n\n/**\n * A data model implementation for in-memory JSON data.\n */\nexport\nclass JSONModel extends DataModel {\n  /**\n   * Create a data model with static JSON data.\n   *\n   * @param options - The options for initializing the data model.\n   */\n  constructor(options: JSONModel.IOptions) {\n    super();\n    let split = Private.splitFields(options.schema);\n    this._data = options.data;\n    this._bodyFields = split.bodyFields;\n    this._headerFields = split.headerFields;\n    this._missingValues = Private.createMissingMap(options.schema);\n  }\n\n  /**\n   * Get the row count for a region in the data model.\n   *\n   * @param region - The row region of interest.\n   *\n   * @returns - The row count for the region.\n   */\n  rowCount(region: DataModel.RowRegion): number {\n    if (region === 'body') {\n      return this._data.length;\n    }\n    return 1;  // TODO multiple column-header rows?\n  }\n\n  /**\n   * Get the column count for a region in the data model.\n   *\n   * @param region - The column region of interest.\n   *\n   * @returns - The column count for the region.\n   */\n  columnCount(region: DataModel.ColumnRegion): number {\n    if (region === 'body') {\n      return this._bodyFields.length;\n    }\n    return this._headerFields.length;\n  }\n\n  /**\n   * Get the data value for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns - The data value for the specified cell.\n   *\n   * #### Notes\n   * A `missingValue` as defined by the schema is converted to `null`.\n   */\n  data(region: DataModel.CellRegion, row: number, column: number): any {\n    // Set up the field and value variables.\n    let field: JSONModel.Field;\n    let value: any;\n\n    // Look up the field and value for the region.\n    switch (region) {\n    case 'body':\n      field = this._bodyFields[column];\n      value = this._data[row][field.name];\n      break;\n    case 'column-header':\n      field = this._bodyFields[column];\n      value = field.title || field.name;\n      break;\n    case 'row-header':\n      field = this._headerFields[column];\n      value = this._data[row][field.name];\n      break;\n    case 'corner-header':\n      field = this._headerFields[column];\n      value = field.title || field.name;\n      break;\n    default:\n      throw 'unreachable';\n    }\n\n    // Test whether the value is a missing value.\n    let missing = (\n      this._missingValues !== null &&\n      typeof value === 'string' &&\n      this._missingValues[value] === true\n    );\n\n    // Return the final value.\n    return missing ? null : value;\n  }\n\n  /**\n   * Get the metadata for a cell in the data model.\n   *\n   * @param region - The cell region of interest.\n   *\n   * @param row - The row index of the cell of of interest.\n   *\n   * @param column - The column index of the cell of interest.\n   *\n   * @returns The metadata for the cell.\n   */\n  metadata(region: DataModel.CellRegion, row: number, column: number): DataModel.Metadata {\n    if (region === 'body' || region === 'column-header') {\n      return this._bodyFields[column];\n    }\n    return this._headerFields[column];\n  }\n\n  private _data: JSONModel.DataSource;\n  private _bodyFields: JSONModel.Field[];\n  private _headerFields: JSONModel.Field[];\n  private _missingValues: Private.MissingValuesMap | null;\n}\n\n\n/**\n * The namespace for the `JSONModel` class statics.\n */\nexport\nnamespace JSONModel {\n  /**\n   * An object which describes a column of data in the model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export\n  type Field = {\n    /**\n     * The name of the column.\n     *\n     * This is used as the key to extract a value from a data record.\n     * It is also used as the column header label, unless the `title`\n     * property is provided.\n     */\n    readonly name: string;\n\n    /**\n     * The type of data held in the column.\n     */\n    readonly type?: string;\n\n    /**\n     * The format of the data in the column.\n     */\n    readonly format?: string;\n\n    /**\n     * The human readable name for the column.\n     *\n     * This is used as the label for the column header.\n     */\n    readonly title?: string;\n\n    // TODO want/need support for any these?\n    // description?: string;\n    // constraints?: IConstraints;\n    // rdfType?: string;\n  };\n\n  /**\n   * An object when specifies the schema for a data model.\n   *\n   * #### Notes\n   * This is based on the JSON Table Schema specification:\n   * https://specs.frictionlessdata.io/table-schema/\n   */\n  export\n  type Schema = {\n    /**\n     * The fields which describe the data model columns.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly fields: Field[];\n\n    /**\n     * The values to treat as \"missing\" data.\n     *\n     * Missing values are automatically converted to `null`.\n     */\n    readonly missingValues?: string[];\n\n    /**\n     * The field names which act as primary keys.\n     *\n     * Primary key fields are rendered as row header columns.\n     */\n    readonly primaryKey?: string | string[];\n\n    // TODO want/need support for this?\n    // foreignKeys?: IForeignKey[];\n  };\n\n  /**\n   * A type alias for a data source for a JSON data model.\n   *\n   * A data source is an array of JSON object records which represent\n   * the rows of the table. The keys of the records correspond to the\n   * field names of the columns.\n   */\n  export\n  type DataSource = ReadonlyArray<ReadonlyJSONObject>;\n\n  /**\n   * An options object for initializing a JSON data model.\n   */\n  export\n  interface IOptions {\n    /**\n     * The schema for the for the data model.\n     *\n     * The schema should be treated as an immutable object.\n     */\n    schema: Schema;\n\n    /**\n     * The data source for the data model.\n     *\n     * The data model takes full ownership of the data source.\n     */\n    data: DataSource;\n  }\n}\n\n\n/**\n * The namespace for the module implementation details.\n */\nnamespace Private {\n  /**\n   * An object which holds the results of splitting schema fields.\n   */\n  export\n  type SplitFieldsResult = {\n    /**\n     * The non-primary key fields to use for the grid body.\n     */\n    bodyFields: JSONModel.Field[];\n\n    /**\n     * The primary key fields to use for the grid headers.\n     */\n    headerFields: JSONModel.Field[];\n  };\n\n  /**\n   * Split the schema fields into header and body fields.\n   */\n  export\n  function splitFields(schema: JSONModel.Schema): SplitFieldsResult {\n    // Normalize the primary keys.\n    let primaryKeys: string[];\n    if (schema.primaryKey === undefined) {\n      primaryKeys = [];\n    } else if (typeof schema.primaryKey === 'string') {\n      primaryKeys = [schema.primaryKey];\n    } else {\n      primaryKeys = schema.primaryKey;\n    }\n\n    // Separate the fields for the body and header.\n    let bodyFields: JSONModel.Field[] = [];\n    let headerFields: JSONModel.Field[] = [];\n    for (let field of schema.fields) {\n      if (primaryKeys.indexOf(field.name) === -1) {\n        bodyFields.push(field);\n      } else {\n        headerFields.push(field);\n      }\n    }\n\n    // Return the separated fields.\n    return { bodyFields, headerFields };\n  }\n\n  /**\n   * A type alias for a missing value map.\n   */\n  export\n  type MissingValuesMap = { [key: string]: boolean };\n\n  /**\n   * Create a missing values map for a schema.\n   *\n   * This returns `null` if there are no missing values.\n   */\n  export\n  function createMissingMap(schema: JSONModel.Schema): MissingValuesMap | null {\n    // Bail early if there are no missing values.\n    if (!schema.missingValues || schema.missingValues.length === 0) {\n      return null;\n    }\n\n    // Collect the missing values into a map.\n    let result: MissingValuesMap = Object.create(null);\n    for (let value of schema.missingValues) {\n      result[value] = true;\n    }\n\n    // Return the populated map.\n    return result;\n  }\n}\n"]}